<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>concurrency on Maciek's blog</title><link>http://mmakowski.github.io/blog/tags/concurrency/</link><description>Recent content in concurrency on Maciek's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 28 Nov 2015 00:00:00 +0000</lastBuildDate><atom:link href="http://mmakowski.github.io/blog/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>A Pitfall of Global Execution Context</title><link>http://mmakowski.github.io/blog/technology/a-pitfall-of-global-execution-context/</link><pubDate>Sat, 28 Nov 2015 00:00:00 +0000</pubDate><guid>http://mmakowski.github.io/blog/technology/a-pitfall-of-global-execution-context/</guid><description>The convenience of Scala’s Future concept makes it the default tool for all kinds of programming tasks that call for asynchrony. There seems nothing simpler than wrapping a block of code in future { }, then, when compilation fails, importing scala.concurrent.ExecutionContext.Implicits.global, and we’re done, the code runs asynchronously. We can then use the computed result (if any) in further futures, or if we want to break out of the future world, do Await.</description></item><item><title>Scala Futures on a Single Thread</title><link>http://mmakowski.github.io/blog/technology/scala-futures-on-a-single-thread/</link><pubDate>Sat, 05 Oct 2013 00:00:00 +0000</pubDate><guid>http://mmakowski.github.io/blog/technology/scala-futures-on-a-single-thread/</guid><description>Futures, introduced into Scala standard library in version 2.10, quickly became one of the cornerstones of Scala concurrency. Their main selling point is the ease of composition. A standard example of that involves asynchronous calls to a number of remote services and computation of the answer once all of the responses are collected:
def price(itemId: Id): Future[Price] = ??? def availability(itemId: Id): Future[Int] = ??? def orderQuote(itemId: Id, quantityRequired: Int): Future[Option[Price]] = for { unitPrice &amp;lt;- price(itemId) quantityAvailable &amp;lt;- availability(itemId) } yield if (quantityAvailable &amp;gt;= quantityRequired) Some(quantityRequired * unitPrice) else None Here price and availability are service calls that can potentially take long time and are meant to be executed in parallel.</description></item></channel></rss>