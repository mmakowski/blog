<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>scala on Maciek's blog</title><link>https://blog.mmakowski.com/tags/scala/</link><description>Recent content in scala on Maciek's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 02 Sep 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.mmakowski.com/tags/scala/index.xml" rel="self" type="application/rss+xml"/><item><title>A Software Developer's Take on Zeppelin Notebooks</title><link>https://blog.mmakowski.com/technology/a-software-developers-take-on-zeppelin-notebooks/</link><pubDate>Sat, 02 Sep 2017 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/a-software-developers-take-on-zeppelin-notebooks/</guid><description>For the past two months I have used Zeppelin-based notebooks as my primary IDE for data exploration, experiment documentation and prototyping of production code. While the former two notebook use cases are perfectly legitimate, I would argue that Zeppelin is poorly suited for production code prototyping. This is primarily due to high barrier to extraction of common code to libraries. In Jupyter, for example, all it takes to extract a function to a shareable module is to copy it from the notebook to a Python file stored in the same directory as the notebook.</description></item><item><title>A Pitfall of Global Execution Context</title><link>https://blog.mmakowski.com/technology/a-pitfall-of-global-execution-context/</link><pubDate>Sat, 28 Nov 2015 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/a-pitfall-of-global-execution-context/</guid><description>The convenience of Scala’s Future concept makes it the default tool for all kinds of programming tasks that call for asynchrony. There seems nothing simpler than wrapping a block of code in future { }, then, when compilation fails, importing scala.concurrent.ExecutionContext.Implicits.global, and we’re done, the code runs asynchronously. We can then use the computed result (if any) in further futures, or if we want to break out of the future world, do Await.</description></item><item><title>Scala in North Lakes</title><link>https://blog.mmakowski.com/technology/scala-in-north-lakes/</link><pubDate>Wed, 23 Sep 2015 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/scala-in-north-lakes/</guid><description>A Scala conference, far from any significant technology hub? With no call for papers? With hikes planned in what is one of the wettest parts of the country? Without Martin Odersky? What could possibly go wrong? A lot. But, apart from a few of the speakers not making it, nothing did, and Scala World was probably as good as a Scala conference can get.
Instead of summarising individual talks, I will focus on the major themes.</description></item><item><title>Scala Futures on a Single Thread</title><link>https://blog.mmakowski.com/technology/scala-futures-on-a-single-thread/</link><pubDate>Sat, 05 Oct 2013 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/scala-futures-on-a-single-thread/</guid><description>Futures, introduced into Scala standard library in version 2.10, quickly became one of the cornerstones of Scala concurrency. Their main selling point is the ease of composition. A standard example of that involves asynchronous calls to a number of remote services and computation of the answer once all of the responses are collected:
def price(itemId: Id): Future[Price] = ??? def availability(itemId: Id): Future[Int] = ??? def orderQuote(itemId: Id, quantityRequired: Int): Future[Option[Price]] = for { unitPrice &amp;lt;- price(itemId) quantityAvailable &amp;lt;- availability(itemId) } yield if (quantityAvailable &amp;gt;= quantityRequired) Some(quantityRequired * unitPrice) else None Here price and availability are service calls that can potentially take long time and are meant to be executed in parallel.</description></item><item><title>Functional Programming Exchange 2013</title><link>https://blog.mmakowski.com/technology/functional-programming-exchange-2013/</link><pubDate>Fri, 15 Mar 2013 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/functional-programming-exchange-2013/</guid><description>After slightly disappointing FPX 2012, this year’s edition of Skills Matter-run one day gathering of functional programming enthusiasts bounced back with promising speaker line-up. The participant numbers were up compared to last year and seem to have even exceeded the excellent 2011 edition.
Adventures with Types in Haskell If anyone had any doubt about the reputation Simon Peyton Jones enjoys in fuctional programming community, the enthusiastic welcome he received must have dispelled it.</description></item><item><title>Test of Github as a Tutorial Hosting Platform - Literate Specifications with specs2</title><link>https://blog.mmakowski.com/technology/test-of-github-as-a-tutorial-hosting-platform-literate-specifications-with-specs2/</link><pubDate>Sun, 15 Jan 2012 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/test-of-github-as-a-tutorial-hosting-platform-literate-specifications-with-specs2/</guid><description>This is an experiment with how well Github is suited to host coding tutorials. Turns out that the navigation and presentation could be a bit better, but overall it seems to be fairly usable. And since the tutorial has the form of a git repository, we are not restricted to using Github, but can come up with software that is specifically designed to present the subsequent commits as steps of a tutorial… clearly, DVCS and self-contained repositories are very powerful ideas.</description></item><item><title>Scala LiftOff London 2011 - Day 1</title><link>https://blog.mmakowski.com/technology/scala-liftoff-london-2011-day-1/</link><pubDate>Sat, 15 Oct 2011 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/scala-liftoff-london-2011-day-1/</guid><description>Compared to last year’s LiftOff, which was an un-conference pretty much all the way, this year’s is split into morning, structured sessions, and afternoon open spaces resembling 2010 format. As usual, I tried to jot down the more interesting points from the day. The below is by no means a complete record and definitely suffers from insufficient editing and research (no time for that, sorry!). With this disclaimer out of the way:</description></item><item><title>Scala Exchange 2011 - Day 1</title><link>https://blog.mmakowski.com/technology/scala-exchange-2011-day-1/</link><pubDate>Fri, 15 Jul 2011 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/scala-exchange-2011-day-1/</guid><description>I’ve attended a day full of Scala-related talks at Scala Exchange 2011, and, as was the case with the previous events organised by SkillsMatter, I felt that relating what was said and what my impressions were will help me digest all the new pieces of information. So, here it goes.
State of Scala In the keynote talk Martin Odersky explained how his perception of usefulness of functional programming in the real world shifted from a good fit for XML manipulation to concurrent and parallel computing.</description></item><item><title>Functional Programming Exchange 2011</title><link>https://blog.mmakowski.com/technology/functional-programming-exchange-2011/</link><pubDate>Sun, 20 Mar 2011 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/functional-programming-exchange-2011/</guid><description>After the success that Scala LiftOff London 2010 was I didn’t hesitate long before signing up for a number of other Scala and functional programming events hosted by Skills Matter. The first of them was Functional Programming Exchange. Below are notes from most of the sessions of this one-day conference.
Managing Parallelism - Embrace Diversity The event started with Simon Peyton Jones discussing the importance of parallel computing, how different problems call for different approaches and how functional languages (and Haskell in particular) are well suited for the task.</description></item><item><title>Scala LiftOff London 2010 - Day 2</title><link>https://blog.mmakowski.com/technology/scala-liftoff-london-2010-day-2/</link><pubDate>Mon, 11 Oct 2010 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/scala-liftoff-london-2010-day-2/</guid><description>← Day One
The second and last day of Scala Lift Off did not disappoint. Compared to yesterday, the sessions I attended turned out to be less focussed on presenting concrete projects or results and more on discussing the language features and tools from the position of users discovering them. Overall, less structure, more interaction.
Teasers The day started with half an hour of very short talks by authors of a number of Scala-based projects.</description></item><item><title>Scala LiftOff London 2010 - Day 1</title><link>https://blog.mmakowski.com/technology/scala-liftoff-london-2010-day-1/</link><pubDate>Sun, 10 Oct 2010 00:00:00 +0000</pubDate><guid>https://blog.mmakowski.com/technology/scala-liftoff-london-2010-day-1/</guid><description>The first day of this year’s Scala Lift Off London exceeded my modest expectations. It was full of excellent presentations and interesting discussions attended by very friendly folk. I trust tomorrow will not be worse; in the mean time here are some notes from the sessions I attended.
Session 1: From Java to Scala Graham Tackley of guardian.co.uk told us about the experience of his team with embracing Scala. Guardian.co.uk had been a Java shop and when a project to provide API to access all of their content had been started their technology stack of choice was Java, Guice and Apache Solr.</description></item></channel></rss>