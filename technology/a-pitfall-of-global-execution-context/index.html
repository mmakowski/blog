<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>A Pitfall of Global Execution Context | Maciek's blog</title><link rel=stylesheet href=/blog/css/style.css><link rel=stylesheet href=/blog/css/fonts.css></head><body><nav><ul class=menu><li><a href=/blog/technology/>Tech</a></li><li><a href=/blog/travel/>Travel</a></li><li><a href=/blog/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>A Pitfall of Global Execution Context</span></h1><h2 class=date>2015/11/28</h2></div><main><p>The convenience of Scala’s <code>Future</code> concept makes it the default tool for all kinds of programming tasks that call for asynchrony. There seems nothing simpler than wrapping a block of code in <code>future { }</code>, then, when compilation fails, importing <code>scala.concurrent.ExecutionContext.Implicits.global</code>, and we’re done, the code runs asynchronously. We can then use the computed result (if any) in further futures, or if we want to break out of the future world, do <code>Await.result</code>. This is indeed easy, and does the job in many cases, but when it does not, might cause a bit of head scratching. Below is one example of such pitfall.</p><h2 id=the-conundrum>The Conundrum</h2><p>Suppose we wanted to test the behaviour of a data store that is expected to support multiple concurrent readers. Say, there is a suspicion that every now and then, when faced with concurrent reads and writes, some of the readers obtain inconsistent data. We could write the test as an application that performs writes and multiple reads in parallel, then run it for a long time to give us some confidence that the issue does not occur. Our first attempt could look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>scala.annotation.tailrec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>scala.concurrent.ExecutionContext.Implicits.global</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>scala.concurrent.future</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>object</span> <span style=color:#458;font-weight:700>Test</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>val</span> consumerCount <span style=color:#000;font-weight:700>=</span> <span style=color:#099>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>def</span> main<span style=color:#000;font-weight:700>(</span>args<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Array</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>String</span><span style=color:#000;font-weight:700>])</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>(</span><span style=color:#099>1</span> to consumerCount<span style=color:#000;font-weight:700>).</span>foreach <span style=color:#000;font-weight:700>{</span> consumer<span style=color:#000;font-weight:700>.</span>start <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>    producer<span style=color:#000;font-weight:700>.</span>start<span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>Thread</span><span style=color:#000;font-weight:700>.</span>sleep<span style=color:#000;font-weight:700>(</span><span style=color:#099>10</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#099>1000</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>object</span> <span style=color:#458;font-weight:700>consumer</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>def</span> start<span style=color:#000;font-weight:700>(</span>id<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Int</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> future <span style=color:#000;font-weight:700>{</span> consume<span style=color:#000;font-weight:700>(</span>id<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#3c5d5d;font-weight:700>@tailrec</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>def</span> consume<span style=color:#000;font-weight:700>(</span>id<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Int</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      readDataFromTheSourceAndVerifyTheConsistency<span style=color:#000;font-weight:700>(</span>id<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      consume<span style=color:#000;font-weight:700>(</span>id<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>def</span> readDataFromTheSourceAndVerifyTheConsistency<span style=color:#000;font-weight:700>(</span>id<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Int</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>s&#34;consumer </span><span style=color:#d14>$id</span><span style=color:#d14> consuming...&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      <span style=color:#458;font-weight:700>Thread</span><span style=color:#000;font-weight:700>.</span>sleep<span style=color:#000;font-weight:700>(</span><span style=color:#099>1</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>s&#34;consumer </span><span style=color:#d14>$id</span><span style=color:#d14> consumed&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>object</span> <span style=color:#458;font-weight:700>producer</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>def</span> start<span style=color:#000;font-weight:700>()</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> future <span style=color:#000;font-weight:700>{</span> produce<span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#3c5d5d;font-weight:700>@tailrec</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>def</span> produce<span style=color:#000;font-weight:700>()</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      writeANewBatchOfData<span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>      produce<span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>def</span> writeANewBatchOfData<span style=color:#000;font-weight:700>()</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>s&#34;producer producing...&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      <span style=color:#458;font-weight:700>Thread</span><span style=color:#000;font-weight:700>.</span>sleep<span style=color:#000;font-weight:700>(</span><span style=color:#099>100</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>s&#34;producer produced&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>The tail of the output of this test, on my system, looked as follows:</p><pre tabindex=0><code>[...]
consumer 7 consuming...
consumer 4 consumed
consumer 4 consuming...
consumer 3 consumed
consumer 3 consuming...
consumer 6 consumed
consumer 6 consuming...
consumer 9 consumed
consumer 9 consuming...
consumer 8 consumed
consumer 8 consuming...
consumer 2 consumed
consumer 2 consuming...
consumer 10 consumed
consumer 10 consuming...
consumer 5 consumed
consumer 5 consuming...
consumer 7 consumed
consumer 7 consuming...
consumer 4 consumed
consumer 4 consuming...
consumer 9 consumed
consumer 9 consuming...
consumer 8 consumed
consumer 8 consuming...
</code></pre><p>The consumers seem to be exhibiting reasonable parallelism but due to the cost of consumption relative to the cost of production, they have nothing to consume most of the time – it takes many loops of each consumer until the producer manages to push a new batch of data. To ensure that the test indeed exercises parallel reads, we only want the consumers to proceed with the next iteration once there is something new to consume. Java’s <code>CyclicBarrier</code> seems to be a perfect fit for this synchronisation problem: both consumers and producers will reach the barrier and then continue with the next iteration – production or consumption – in lock-step.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>scala.annotation.tailrec</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>scala.concurrent.ExecutionContext.Implicits.global</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>scala.concurrent.future</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>java.util.concurrent.CyclicBarrier</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>object</span> <span style=color:#458;font-weight:700>Test</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>val</span> consumerCount <span style=color:#000;font-weight:700>=</span> <span style=color:#099>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>def</span> main<span style=color:#000;font-weight:700>(</span>args<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Array</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>String</span><span style=color:#000;font-weight:700>])</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>val</span> dataBarrier <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>new</span> <span style=color:#458;font-weight:700>CyclicBarrier</span><span style=color:#000;font-weight:700>(</span>consumerCount <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>(</span><span style=color:#099>1</span> to consumerCount<span style=color:#000;font-weight:700>).</span>foreach <span style=color:#000;font-weight:700>{</span> consumer<span style=color:#000;font-weight:700>.</span>start<span style=color:#000;font-weight:700>(</span>dataBarrier<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>    producer<span style=color:#000;font-weight:700>.</span>start<span style=color:#000;font-weight:700>(</span>dataBarrier<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>Thread</span><span style=color:#000;font-weight:700>.</span>sleep<span style=color:#000;font-weight:700>(</span><span style=color:#099>10</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#099>1000</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>object</span> <span style=color:#458;font-weight:700>consumer</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>def</span> start<span style=color:#000;font-weight:700>(</span>consumeBarrier<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>CyclicBarrier</span><span style=color:#000;font-weight:700>)(</span>id<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Int</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> future <span style=color:#000;font-weight:700>{</span> consume<span style=color:#000;font-weight:700>(</span>consumeBarrier<span style=color:#000;font-weight:700>,</span> id<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#3c5d5d;font-weight:700>@tailrec</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>def</span> consume<span style=color:#000;font-weight:700>(</span>consumeBarrier<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>CyclicBarrier</span><span style=color:#000;font-weight:700>,</span> id<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Int</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      consumeBarrier<span style=color:#000;font-weight:700>.</span>await<span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>      readDataFromTheSourceAndVerifyTheConsistency<span style=color:#000;font-weight:700>(</span>id<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      consume<span style=color:#000;font-weight:700>(</span>consumeBarrier<span style=color:#000;font-weight:700>,</span> id<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>def</span> readDataFromTheSourceAndVerifyTheConsistency<span style=color:#000;font-weight:700>(</span>id<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Int</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>s&#34;consumer </span><span style=color:#d14>$id</span><span style=color:#d14> consuming...&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      <span style=color:#458;font-weight:700>Thread</span><span style=color:#000;font-weight:700>.</span>sleep<span style=color:#000;font-weight:700>(</span><span style=color:#099>1</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>s&#34;consumer </span><span style=color:#d14>$id</span><span style=color:#d14> consumed&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>object</span> <span style=color:#458;font-weight:700>producer</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>def</span> start<span style=color:#000;font-weight:700>(</span>produceBarrier<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>CyclicBarrier</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> future <span style=color:#000;font-weight:700>{</span> produce<span style=color:#000;font-weight:700>(</span>produceBarrier<span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#3c5d5d;font-weight:700>@tailrec</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>def</span> produce<span style=color:#000;font-weight:700>(</span>produceBarrier<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>CyclicBarrier</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      writeANewBatchOfData<span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>      produceBarrier<span style=color:#000;font-weight:700>.</span>await<span style=color:#000;font-weight:700>()</span>
</span></span><span style=display:flex><span>      produce<span style=color:#000;font-weight:700>(</span>produceBarrier<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>private</span> <span style=color:#000;font-weight:700>def</span> writeANewBatchOfData<span style=color:#000;font-weight:700>()</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>Unit</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>      println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>s&#34;producer producing...&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      <span style=color:#458;font-weight:700>Thread</span><span style=color:#000;font-weight:700>.</span>sleep<span style=color:#000;font-weight:700>(</span><span style=color:#099>100</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>      println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>s&#34;producer produced&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Now, when we run this, we can see that the consumers only execute once producer has produced a new batch, and while it is producing the next one:</p><pre tabindex=0><code>[...]
producer produced
producer producing...
consumer 10 consuming...
consumer 8 consuming...
consumer 5 consuming...
consumer 3 consuming...
consumer 9 consuming...
consumer 7 consuming...
consumer 1 consuming...
consumer 6 consuming...
consumer 4 consuming...
consumer 2 consuming...
consumer 10 consumed
consumer 8 consumed
consumer 5 consumed
consumer 3 consumed
consumer 9 consumed
consumer 7 consumed
consumer 1 consumed
consumer 6 consumed
consumer 4 consumed
consumer 2 consumed
producer produced
producer producing...
consumer 10 consuming...
consumer 8 consuming...
consumer 5 consuming...
consumer 3 consuming...
consumer 9 consuming...
consumer 7 consuming...
consumer 1 consuming...
consumer 2 consuming...
consumer 4 consuming...
consumer 6 consuming...
consumer 10 consumed
consumer 8 consumed
consumer 5 consumed
consumer 3 consumed
consumer 9 consumed
consumer 7 consumed
consumer 1 consumed
consumer 2 consumed
consumer 4 consumed
consumer 6 consumed
</code></pre><p>This should give us a good chance of spotting an anomaly due to concurrent production and consumption. Now, we push this to the continuous integration environment and see the test freezing; not even a single iteration of any consumer is executed.</p><p>What has happened?</p><h2 id=the-cause>The Cause</h2><p>Among many differences between the local and continuous ingegration environment (e.g. Windows vs. Linux), a significant one in this case is the number of cores. While our development workstation had six hyper-threaded cores, the CI box has only four. The <a href=http://www.scala-lang.org/api/current/index.html#scala.concurrent.ExecutionContext%24%24Implicits%24@global:scala.concurrent.ExecutionContextExecutor>documentation</a> of <code>scala.concurrent.ExecutionContext.Implicits.global</code> notes:</p><blockquote><p>The default <code>ExecutionContext</code> implementation is backed by a work-stealing thread pool. By default, the thread pool uses a target number of worker threads equal to the number of available processors.</p></blockquote><p>We are asking the test to spawn ten consumers and one producer, i.e. 11 tasks. While they can be allocated among the 12 virtual cores of the workstation, the CI only has 8 slots, meaning that 8 of the tasks start executing and wait on the barrier, while the remaining 3 have no chance to be scheduled and allow everyone to pass the barrier.</p><p>Does it mean we cannot get higher degree of parallelism for our producer and consumers? No, it does not; these tasks spent the bulk of their time performing I/O, so they are not CPU-bound and their number should not be restricted by the number of available processors.</p><h2 id=the-fix>The Fix</h2><p>Once we know the above, a fix is pretty obvious. Instead of:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>scala.concurrent.ExecutionContext.Implicits.global</span>
</span></span></code></pre></div><p>define:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>implicit</span> <span style=color:#000;font-weight:700>val</span> ec <span style=color:#000;font-weight:700>=</span> scala<span style=color:#000;font-weight:700>.</span>concurrent<span style=color:#000;font-weight:700>.</span><span style=color:#458;font-weight:700>ExecutionContext</span><span style=color:#000;font-weight:700>.</span>fromExecutor<span style=color:#000;font-weight:700>(</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>new</span> java<span style=color:#000;font-weight:700>.</span>util<span style=color:#000;font-weight:700>.</span>concurrent<span style=color:#000;font-weight:700>.</span><span style=color:#458;font-weight:700>ForkJoinPool</span><span style=color:#000;font-weight:700>(</span>consumerCount <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span><span style=color:#000;font-weight:700>))</span>
</span></span></code></pre></div><p>in a scope that includes all invocations of <code>future</code>.</p><h2 id=conclusion>Conclusion</h2><p>I would not use the <em>global</em> execution context whenever the asynchronous computations require any kind of synchronisation, as it can easily end in a deadlock, as in the example above. Not only that – spawning anything long-running in this fashion might cause exhaustion of the global fork-join pool and would require reasoning about all asynchronous computations in the program globally. Perhaps more generally, <code>future</code> should not be treated as a drop-in construct that just makes things go faster and not block. Whenever tempted to do this, always consider how you expect the executor of this future to behave, and, if in doubt, define a local one.</p></main><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2022. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>