<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>A Software Developer's Take on Zeppelin Notebooks | Maciek's blog</title><link rel=stylesheet href=/blog/css/style.css><link rel=stylesheet href=/blog/css/fonts.css></head><body><nav><ul class=menu><li><a href=/blog/technology/>Tech</a></li><li><a href=/blog/travel/>Travel</a></li><li><a href=/blog/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>A Software Developer&rsquo;s Take on Zeppelin Notebooks</span></h1></div><main><p>For the past two months I have used <a href=https://zeppelin.apache.org/>Zeppelin</a>-based notebooks as my primary IDE for data exploration, experiment documentation and prototyping of production code. While the former two notebook use cases are perfectly legitimate, I would argue that Zeppelin is poorly suited for production code prototyping. This is primarily due to high barrier to extraction of common code to libraries. In Jupyter, for example, all it takes to extract a function to a shareable module is to copy it from the notebook to a Python file stored in the same directory as the notebook. That file can then be incorporated in the production code base, unit tests can be written for it using the stard testing frameworks, and so on. In Zeppelin + Scala Spark, for an extracted function to be available to the notebooks, the function has to be copied to a file, compiled to a <code>.class</code> file, added to the classpath of the interpreter, and the interpreter has to be restarted. As a result, noone bothers; the code lives on in the notebook, and any unit tests developed (in the notebook) around it have to be ported to whatever testing framework is used in the production code base.</p><p><img src=zeppelin.png alt="Zeppelin notebook UI"></p><p>The reality of the environment I ended up working in was such, though, that prototyping in a Zeppelin notebook appeared the least cumbersome option. In the process, I have developed a few working practices which I would like to share here. They are applicable to both prototyping and purely experimental notebooks.</p><h2 id=version-control>Version Control</h2><p>Zeppelin notebooks are stored in JSON files, code and output together, with the code encoded in such a way that line breaks are not present in the JSON. This makes it poorly suited for comparing different versions using standard tools such as <code>diff</code>. Collaboration on a single notebook is also tricky, since merging of changes does not work. Still, version control is essential for reproducibility of the experiments. I store all notebooks in git, and after running each experiment create a tag in the git repository, with the tag name corresponding to the experiment id. The exact way to work with a git repository would depend on the specific setup of the Zeppelin; in my case, the Zeppelin server runs on a remote machine, so instead of SSH-ing in every time I need to checkpoint my work I found it convenient to create a dedicated notebook that performs the git committing and tagging using a shell cell.</p><h2 id=structure>Structure</h2><p>As noted, the sharing of code across Zeppelin notebooks is inconvenient. Things look a bit better when it comes to avoiding unnecessary code duplication within a single notebook, although here we also run into an obvious restriction: since the cells are meant to execute in sequence, the functionality must be built bottom-up. This means gradually creating more and more complex building blocks from those defined previously, and eventually putting them all together into the desired, top-level functionality. It is the opposite to how I prefer to read the code: first high-level logic, then the implementation details. That concern aside, it is still perfectly possible to apply the usual practices of extracting common code into reusable functions and keeping each function small and to the point. Scala offers good syntactic support for that.</p><p>I attempt to ensure that the experiment or prototyping notebooks I develop are safe to run in their entirety; the side effects should not destroy any previously created data. If a notebook writes out any data – and all experiment notebooks should save the results in some form – I write it under file name or Parquet key that is either derived from the experiment id or input parmeters, or is a GUID. Where possible, I try to make the notebooks deterministic. Wherever a random number generator is used, I always pass a constant seed in. This acts as an additional safeguard against accidental overwrite of previous results: if they do get overwritten, as long as nothing significant has changed in the notebook the new results will be the same. Finally, all writing in my notebooks tends to happen in the final cell. If there is any risk that a rerun could overwrite some data, or if I just don’t want to save on every run, it is easy to disable execution of this single cell.</p><p>In summary, this is the high-level structure that works well for the majority of notebooks I develop:</p><ul><li>description: one-paragraph summary of what the notebook does</li><li>frequently changing parameters: experiment id, the inputs or keys to read them from</li><li>infrequently changing parameters and constants: paths of data sources, RNG seed</li><li>functions and their unit tests</li><li>invocation of the main experiment/prototype function</li><li>output and visualisation of results</li><li>storage of results</li></ul><h2 id=testing>Testing</h2><p>Ease of unit testing is a well-known property of code factored into small, focussed functions. As such, I tend to write a set of test cases for each such function, in a cell that immediately follows. This cuts down on the time spent debugging, since as we move on to building higher-level functionality we can be confident that the blocks work as intended. Scala’s <code>assert</code> function is an adequate substitute for a fully-fledged testing framework. By way of illustration, say, we had a cell with the following function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>def</span> denoise<span style=color:#000;font-weight:700>(</span>text<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>String</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>=</span> text
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>.</span>toLowerCase
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>.</span>replaceAll<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#34;&#34;&#34;[^\s\w]&#34;&#34;&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#d14>&#34;&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>.</span>split<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#34;&#34;&#34;\s+&#34;&#34;&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>.</span>filter<span style=color:#000;font-weight:700>(</span>w <span style=color:#000;font-weight:700>=&gt;</span> <span style=color:#000;font-weight:700>!</span>stopWords<span style=color:#000;font-weight:700>.</span>contains<span style=color:#000;font-weight:700>(</span>w<span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>.</span>mkString<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#34; &#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>The cell that follows could contain:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#34;test case: stop words&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>val</span> result <span style=color:#000;font-weight:700>=</span> denoise<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#34;a holiday a holiday and the first one of the year&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    assert<span style=color:#000;font-weight:700>(</span>result <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#34;holiday holiday and first one of year&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#d14>&#34;result: &#34;</span> <span style=color:#000;font-weight:700>+</span> result<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#34;test case: lower case&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>val</span> result <span style=color:#000;font-weight:700>=</span> denoise<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#34;FOO BAR&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    assert<span style=color:#000;font-weight:700>(</span>result <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#34;foo bar&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#d14>&#34;result: &#34;</span> <span style=color:#000;font-weight:700>+</span> result<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// etc.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>println<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#34;Passed.&#34;</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p><img src=zeppelin-unit-tests.png alt="Unit test code in a Zeppelin notebook"></p><p>The curly braces around each test case make all variables defined in it local, so that they do not pollute the global name space. Additionally, they ensure that only the output explicitly printed appears in the notebook, cutting down on the noise. I tend to hide the <em>output</em> of the function cell (it is not interesting, unless the function fails to compile) and the <em>code</em> of the unit test cell, to make the information visible in the notebook more relevant for the reader.</p><p>One issue with this setup that I have not yet figured out how to overcome is that in Zeppelin a failure of one cell does not prevent further ones from executing. Consequently, when running the notebook, we have to manually check each unit test cell for failures; otherwise, if the code compiles, the experiment could run and write its (potentially erroneous) results despite some of the unit test assertions failing.</p><h2 id=-->* * *</h2><p>While I appreciate the convenience of rich, heterogeneous REPL, I am still not quite sold on notebooks. I have seen them used as vehicles for building data transformation pipelines – one notebook to import data from flat files into Parquet, another to transform to a different format, yet another to apply a classifier, etc. A pipeline constructed in this way is just a collection of disjoint pieces with no overall control over the whole, and as such makes the provenance of a given piece of data very difficult to establish. I would be interested in experimenting with tools such as <a href=https://pachyderm.com>Pachyderm</a> that address this specific issue.</p></main><p class=date>2017/09/02</p><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2022. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>