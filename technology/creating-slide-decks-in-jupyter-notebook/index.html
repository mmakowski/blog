<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Creating slide decks in Jupyter notebook | Maciek's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/technology/>Tech</a></li><li><a href=/travel/>Travel</a></li><li><a href=/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Creating slide decks in Jupyter notebook</span></h1></div><main><p>My job involves organising and analysing data, and training and evaluating machine learning models. In addition, the customers like to see demonstrations or progress updates for their models, so every now and then I also have to put together a slide deck. For better or worse, I use Jupyter notebooks as the main tool for the data management part, so I thought it would be convenient to prepare my slides in the same environment.</p><p>Jupyter has built in support for generating <a href=https://revealjs.com/>reveal.js presentations</a>, so I decided to give that a go. This post first goes through the steps I took to make the slides, in case anyone was looking for a cookbook-style instructions. At the end, there are a few remarks regarding my experience with this way of creating slide decks.</p><p><img src=jupyter-slides.png alt="Jupyter notebook cell producing a line plot"></p><h2 id=guide>Guide</h2><h3 id=slide-metadata>Slide metadata</h3><p>A reveal.js slide deck can be generated from a regular Jupyter notebook, with static content written in Markdown cells and dynamic generated from Python cells. The slideshow metadata can be controlled from a cell toolbar that is enabled through the menu: <em>View > Cell Toolbar > Slideshow</em>. It amounts to a single property, <em>Slide Type</em>. When set to <em>Slide</em>, it indicates that the cell will be a start of a new slide in the deck. <em>Fragment</em> and <em>-</em> (hyphen, or empty) slide type indicate that the cell forms a part of the slide that started earlier. <em>Fragment</em> will cause the content of the cell to be initially hidden, and be revealed on pressing “next” during the presentation. The <em>-</em> type attaches the content to the current slide without requiring additional key presses. It is useful for combining static and dynamic content in a section that should be shown together. <em>Skip</em> cells do not feature in the deck at all, this type is useful for cells that contain blocks of code that does not generate any output that we want included in the deck. <em>Notes</em> cells are for speaker notes; not shown in the main deck, but displayed in the presenter view offered by reveal.js. There is also <em>Sub-Slide</em> type, which I have not used, but which I assume provides the vertical branches in reveal.js.</p><h3 id=slide-deck-export>Slide deck export</h3><p>Plain Jupyter cannot display the slide decks in their final format. There are extensions that <a href=https://damianavila.github.io/RISE/>provide that functionality</a>, but I am yet to try them out, so in this tutorial we will stick to what is available out of the box, which is HTML export. The HTML file will require a reveal.js library to be present, so we will need to download it. Assume we have the following directory structure in our project:</p><pre tabindex=0><code>/project-root
    /demos
       /1
       /lib
    /notebooks
</code></pre><p>We will store the notebook in <code>notebooks</code> directory, and will want to keep the files for the current slide deck in <code>demos/1</code> directory. Let us first make sure reveal.js is available: download the current release from the <a href=https://github.com/hakimel/reveal.js/releases>GitHub releases page</a> and unzip it to <code>demos/lib</code>. As a result we should end up with the library in a directory such as <code>demos/lib/reveal.js-3.7.0</code>. With that in place, we can now export the notebook to a slide deck using <code>jupyter nbconvert</code>. I do it by placing the following cell (<code>Slide Type=Skip</code>) at the top of the notebook:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>!jupyter nbconvert demo1-slides.ipynb <span style=color:#d14>\
</span></span></span><span style=display:flex><span><span style=color:#d14></span>    --to slides <span style=color:#d14>\
</span></span></span><span style=display:flex><span><span style=color:#d14></span>    --output-dir ../demos/1 <span style=color:#d14>\
</span></span></span><span style=display:flex><span><span style=color:#d14></span>    --reveal-prefix<span style=color:#000;font-weight:700>=</span>../lib/reveal.js-3.7.0
</span></span></code></pre></div><p>The <code>output-dir</code> and <code>reveal-prefix</code> arguments make the export aware of our directory structure. Once run, you should end up with the file <code>demos/1/demo1-slides.slides.html</code>, which can be opened in a browser and should immediately work as a reveal.js presentation.</p><h3 id=styling>Styling</h3><p>The Jupyter reveal.js export is by default set up to export both the code and output of Python cells. The audience of my demos is non-technical, and they do not care about the code. <code>nbconvert</code> provides configuration options to exclude the code, as well as the <code>out</code> prompts. We can modify the export cell to include them:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>!jupyter nbconvert demo1-slides.ipynb <span style=color:#d14>\
</span></span></span><span style=display:flex><span><span style=color:#d14></span>    --to slides <span style=color:#d14>\
</span></span></span><span style=display:flex><span><span style=color:#d14></span>    --output-dir ../demos/1 <span style=color:#d14>\
</span></span></span><span style=display:flex><span><span style=color:#d14></span>    --TemplateExporter.exclude_input<span style=color:#000;font-weight:700>=</span>True <span style=color:#d14>\
</span></span></span><span style=display:flex><span><span style=color:#d14></span>    --TemplateExporter.exclude_output_prompt<span style=color:#000;font-weight:700>=</span>True <span style=color:#d14>\
</span></span></span><span style=display:flex><span><span style=color:#d14></span>    --reveal-prefix<span style=color:#000;font-weight:700>=</span>../lib/reveal.js-3.7.0
</span></span></code></pre></div><p>Another feature of the export that is non-ideal is that the output text from <code>print</code>s is shown as preformatted, in HTML <code>&lt;pre></code> tag. This can be addressed by importing <code>display</code> and <code>HTML</code> functions (<code>from IPython.core.display import display, HTML</code>) and then using <code>display(HTML("..."))</code> in place of <code>print</code>. The static content appears more indented than the output of code cells, which is due to an empty prompt area being shown to the left of the static content. To eliminate this, include the following in the first markdown <em>Slide</em> cell:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:navy>style</span>&gt;
</span></span><span style=display:flex><span>.<span style=color:#458;font-weight:700>prompt</span> { <span style=color:#000;font-weight:700>min-width</span>: <span style=color:#099>0</span><span style=color:#458;font-weight:700>ex</span>; }
</span></span><span style=display:flex><span><span style=color:navy>div</span>.<span style=color:#458;font-weight:700>prompt</span> { <span style=color:#000;font-weight:700>width</span>: <span style=color:#099>0</span><span style=color:#458;font-weight:700>ex</span>; }
</span></span><span style=display:flex><span>&lt;/<span style=color:navy>style</span>&gt;
</span></span></code></pre></div><p>In general, all styling can be configured comprehensively in a theme stylesheet, and I will probably look into that if I have to make more slide decks in Jupyter, but for the time being I found it expedient to modify the styles directly in the notebook. Other CSS modifications I found useful were elimination of table borders, which makes Pandas dataframes render nicely:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#458;font-weight:700>rendered_html</span> <span style=color:navy>table</span><span style=color:#000;font-weight:700>,</span> .<span style=color:#458;font-weight:700>rendered_html</span> <span style=color:navy>tr</span><span style=color:#000;font-weight:700>,</span> .<span style=color:#458;font-weight:700>rendered_html</span> <span style=color:navy>td</span><span style=color:#000;font-weight:700>,</span> .<span style=color:#458;font-weight:700>reveal</span> <span style=color:navy>table</span> <span style=color:navy>th</span><span style=color:#000;font-weight:700>,</span> .<span style=color:#458;font-weight:700>reveal</span> <span style=color:navy>table</span> <span style=color:navy>td</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>border</span>: <span style=color:#099>0</span><span style=color:#458;font-weight:700>px</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#458;font-weight:700>reveal</span> <span style=color:navy>thead</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>border-bottom</span>: <span style=color:#099>2</span><span style=color:#458;font-weight:700>px</span> <span style=color:#000;font-weight:700>solid</span> <span style=color:#099>#8c8c8c</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=plots>Plots</h3><p>I used matplotlib for plotting, in the same way I would in a regular notebook. I prefer to output SVG for nice scaling, and also wanted the plots to take the entire slide, so I did the following:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>matplotlib.pyplot</span> <span style=color:#000;font-weight:700>as</span> <span style=color:#555>plt</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>%</span>matplotlib inline
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>%</span>config InlineBackend<span style=color:#000;font-weight:700>.</span>figure_formats <span style=color:#000;font-weight:700>=</span> [<span style=color:#d14>&#39;svg&#39;</span>]
</span></span><span style=display:flex><span>plt<span style=color:#000;font-weight:700>.</span>figure(figsize<span style=color:#000;font-weight:700>=</span>(<span style=color:#099>12</span>,<span style=color:#099>6</span>))
</span></span></code></pre></div><h3 id=pdf-export>PDF export</h3><p>It is a good practice to share the slides with the audience after the presentation, ideally in PDF format, which is easy to open on most computers. Reveal.js’s support for PDF export relies on a custom stylesheet enabled through a query parameter, and the browser’s print to PDF functionality. For the custom stylesheet to work, the presentation has to be delivered by a web server, not just opened from a file on disk. Fortunately, it is easy to start up an ad-hoc web server using Python. In <code>demos</code> directory run:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python3 -m http.server
</span></span></code></pre></div><p>You should now be able to open [[http://0.0.0.0:8000/1/demo1-slides.slides.html?print-pdf]] in a web browser (annoyingly, reveal.js only fully supports Chrome/Chromium for PDF export) and “print” the page to PDF.</p><p>If you use <em>fragments</em> to gradually reveal portions of the slide, each fragment will result in a separate slide in the PDF version of the deck. This is not something I wanted, and the behaviour can be configured through a reveal.js <code>pdfSeparateFragments</code> option, but <code>jupyter nbexport</code> does not provide convenient access to this option, so I ended up hacking the setting into the HTML file directly by adding the following in the export cell, directly after the <code>jupyter nbexport</code> call:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>!sed -i <span style=color:#d14>&#39;s/Reveal\.initialize({/Reveal.initialize({pdfSeparateFragments: false,/&#39;</span> ../demos/1/demo1-slides.slides.html
</span></span></code></pre></div><h2 id=observations>Observations</h2><p>The great thing about using Jupyter for creating slide decks is that I could easily access all the data in the environment, in the way I am used to. For example, I wanted to make a plot of how the progress subject matter experts made on labelling the data over time. I could use pyspark SQL to query the relevant data and then matplotlib to output the plot. In theory tables are also easy to render with the use of Pandas, but I found that less useful in practice: in most cases I wanted to highlight particular cells to draw attention to certain aspects or better explain the data, which meant that I had to include the table in the static content and style it by hand. I only ended up with one case where I could use the dynamic output directly; in all others I ran the calculations in <em>Skip</em> cells to then use those results to hand-design a slide. It is still nice to have the calculations available inline, but copying the data and formatting it separately takes away one of the most compelling arguments for Jupyter as slide deck construction tool.</p><p>And there are disadvantages. For one thing, Jupyter does not support collaborative editing of a notebook, so there is no straightforward way for more than one person to work on the slide deck – if you do, you risk overwriting each other’s changes. Potentially using separate instances of Jupyter and merging the changes to the notebook file using git might work, but I suspect merges of IPython notebook JSON files can be problematic. Secondly, previewing the result requires going through the export and, in case of working with remote Jupyter, downloading of the output HTML file, which is cumbersome and annoying. Previously I used <a href=https://www.rstudio.com/>RStudio</a> with RMarkdown, where just pressing cltr+K rendered the current version of the slides in the preview window. Move to Jupyter feels like a step back. Finally, the default settings, with code and <code>In</code>/<code>Out</code> prompts being included, suggest the slideshow functionality was designed as a way to present notebooks in technical talks rather than design bespoke slide decks that include data-driven elements.</p><p>In summary, in my slideshowing use-case, Jupyter does not provide much advantage over RStudio. I get direct access to the data, but then I have to go through an export cycle to look at the slides. Conversely, with RStudio I have to first export the data in order to use it in the slides, but then viewing the rendered slides is easy – and I tend to do the latter much more frequently than the former. Plus, I get to use <a href=https://ggplot2.tidyverse.org/>ggplot2</a> – probably the best plotting library out there!</p></main><p class=date>31/03/2019</p><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2022. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>