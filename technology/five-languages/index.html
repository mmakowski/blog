<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Five Languages | Maciek's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/technology/>Tech</a></li><li><a href=/travel/>Travel</a></li><li><a href=/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Five Languages</span></h1></div><main><blockquote class=twitter-tweet><p lang=en dir=ltr>Pick three to five programming languages for teaching orthogonal programming paradigms. Which did you choose? Why? Blog and I'll share.</p>&mdash; Rosetta Code (@rosettacode) <a href="https://twitter.com/rosettacode/status/290162783276896258?ref_src=twsrc%5Etfw">January 12, 2013</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p>Interesting you should ask that, Rosetta Code. I’ve been pondering similar questions before, most recently inspired by Bruce Tate’s <a href=http://pragprog.com/book/btlang/seven-languages-in-seven-weeks><em>Seven Languages in Seven Weeks</em></a>, whose languages of choice were sometimes overlapping (e.g. Io and Ruby) while leaving certain areas, such as concatenative languages, unexplored. What languages would I have chosen?</p><p>Let’s start with the paradigms. It’s not a very clear term; is object orientation a paradigm, or just a technique that can be applied to programs written in both imperative and declarative style? Is imperative programming a paradigm? If so, what is procedural programming? The orthogonality requirement complicates things further. Functional programming is not orthogonal to procedural programming, but OO is to both, so how do we choose which features to represent? We are going to just gloss over these formal problems and arbitrarily select five diverse families of programming languages:</p><ul><li>imperative</li><li>functional</li><li>object-oriented</li><li>logic</li><li>Lisp-like</li></ul><p>and then try to cover as many different features within each family, as practical.</p><p>What languages should represent them? Given the limit of five, it might seem that multi-paradigm ones suche as C++, Oz or Scala would offer the biggest bang for the buck. However, considering that the purpose is teaching, we will be better off with smaller languages; ideas can be better appreciated and internalised when presented in a context of a language that was specifically designed around them. As a result our criteria for choice will be:</p><ul><li>small – both conceptually and syntactically: can be learned faster</li><li>“there is only one way”: a paradigm or feature is represented clearly, preferably in its pure form</li><li>representative: contain constructs that are commonly found in other languages representing the same paradigm</li><li>practical: the language is used in the “real world”, there exists a community, tutorials, libraries and other resources</li><li>influential: other languages have been designed after features introduced first in this language</li></ul><h2 id=imperative>Imperative</h2><p>The way contemparary computers work is inherently imperative: code is simply a list of instructions for the CPU. It therefore is fitting to pick for the representative of imperative family a language that makes this connection tangible – a low-level, systems programming language such as <strong>C</strong>. C is perhaps better known for its <a href=http://ioccc.org>obfuscability</a> than for the didactic virtues, but appears to match our criteria fairly well: it is relatively small, doesn’t support any other style than imperative, has a huge codebase written in it and its syntax influenced most of today’s mainstream languages. Students learning C will be exposed to:</p><ul><li>control flow instructions</li><li>manual memory management</li><li>pointers and pointer arithmetic</li><li>undefined behaviour</li></ul><p>Contenders: Assembly, Pascal, Python</p><h2 id=functional>Functional</h2><p>Since we aim for paradigmatic purity and try to avoid obscurity, <strong>Haskell</strong> – a purely functional language with a large, active community is a natural choice. Syntactic sugar notwithstanding, the core is very small and can be boiled down to lambda abstraction and function application. It provides excellent platform to explain concepts such as</p><ul><li>lambda calculus</li><li>laziness</li><li>strong typing</li><li>type inference</li><li>side-effect isolation</li><li>tail call optimisation</li><li>REPL</li></ul><p>Contenders: StandardML, OCaml, also Scheme and Clojure, if we didn’t have a separate category for them</p><h2 id=object-oriented>Object-oriented</h2><p>There are two main flavours of object orientation: object-based and class-based. While the former requires fewer concepts to explain, the latter is much more common in the industry and has an excellent, dogmatic representative: <strong>Smalltalk</strong>. In Smalltalk everything is an object, even conditional instructions are in fact messages sent to Boolean objects. Exactly the conceptual minimalism we have been looking for, at the same time introducing new features such as:</p><ul><li>objects responding to messages</li><li>class inheritance</li><li>dynamic typing</li><li>image-based development environment</li></ul><p>Contenders: Python, Io, Eiffel, Ruby</p><h2 id=logic>Logic</h2><p>Logic programming’s heyday seems to have passed with the 1970s and 80s, but certains concepts are very relevant today. Want to understand how generic Scala collection methods return the most specific type in a given context? Lear about Horn clauses and unification! <strong>Prolog</strong> is by far the most popular language in this paradigm, so we don’t really have much choice if we want a language built around</p><ul><li>logic programming</li><li>term unification</li></ul><p>Contenders: none</p><h2 id=lisp-like>Lisp-like</h2><p>Lisp-likeness is not a paradigm by a long shot; Lisp is usually considered a functional language, and we have already covered that paradigm. The temptation to instead include a concatenative language was high, but the historical importance and influence of Forth pales in comparison with Lisp. Lisp, with its homoiconicity, flexible (some say non-existent) syntax and macro system is a platform of choice for many programming language researchers for a reason. From the countless dialects that mushroomed over the years we will pick <strong>Clojure</strong>, which, beside being a modern language with strong and growing community, will also expose our students to one of the major contemporary runtimes – the Java Virtual Machine. So, here’s what they can learn about:</p><ul><li>abstract syntax trees</li><li>macros</li><li>homoiconicity</li><li>lambda calculus</li><li>dynamic typing</li><li>continuations</li><li>REPL</li><li>JVM</li></ul><p>Contenders: Scheme, Emacs Lisp, also Factor and Forth – if we went for concatenative instead.</p><h2 id=what-is-missing>What is missing?</h2><p>A lot, obviously, especially in the more exotic end of paradigm spectrum, such as concatenative or array-based languages. It would have been nice to include at least one language with advanced module system (e.g. Standard ML) to demonstrate features that help build programs in-the-large. That said, we managed to cover an impressive list of concepts and someone who learns these five languages in reasonable depth can definitely be called a programming erudite.</p></main><p class=date>13/01/2013</p><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2022. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>