<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Haskell Exchange 2013 | Maciek's blog</title><link rel=stylesheet href=/blog/css/style.css><link rel=stylesheet href=/blog/css/fonts.css></head><body><nav><ul class=menu><li><a href=/blog/technology/>Tech</a></li><li><a href=/blog/travel/>Travel</a></li><li><a href=/blog/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Haskell Exchange 2013</span></h1></div><main><p>The second edition of Haskell Exchange has seen over 70 enthusiasts – primarily from London area, but Hungarian and German contingents were noticeable as well – gathered in a crypt of a church in Clerkenwell. The schedule was intense, so unlike with the events I related in the past I won’t attempt to describe all of the talks in detail, but will just focus on the ones which I found particularly intriguing – i.e. ones that had included neat tricks and had been scheduled early enough for my attention not to wander in unexpected directions.</p><h2 id=lenses>Lenses</h2><p><strong>Simon Peyton Jones</strong> usually speaks about his work on new developments in GHC. This time round he decided it’ll be more fun to speak about something he has had little involvement with and picked the <code>lens</code> library by Edward Kmett. Over the last year or so the library has been gaining popularity as a generic solution for manipulating nested data structures. The motivating example was access to a piece of data embedded in nested records, which is not well supported by Haskell, as can be seen in <code>setPostcode</code> function below:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Person</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>P</span> { name <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span>
</span></span><span style=display:flex><span>                , addr <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Address</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Address</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>A</span> { street <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span>
</span></span><span style=display:flex><span>                 , city <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span>
</span></span><span style=display:flex><span>                 , postcode <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span>
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>setPostcode</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Person</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Person</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>setPostcode</span> pc p <span style=color:#000;font-weight:700>=</span> p { addr <span style=color:#000;font-weight:700>=</span> addr p { postcode <span style=color:#000;font-weight:700>=</span> pc }}
</span></span></code></pre></div><p>Lenses address this by providing <code>view</code> (i.e. get), <code>set</code> and <code>over</code> (i.e. update) functions corresponding to fields of the structure. The first impressive insight is that they can be represented as a single function parameterised over a functor:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#458;font-weight:700>Lens</span> s a <span style=color:#000;font-weight:700>=</span> forall f<span style=color:#000;font-weight:700>.</span> <span style=color:#458;font-weight:700>Functor</span> f <span style=color:#000;font-weight:700>=&gt;</span> (a <span style=color:#000;font-weight:700>-&gt;</span> f a) <span style=color:#000;font-weight:700>-&gt;</span> s <span style=color:#000;font-weight:700>-&gt;</span> f s
</span></span></code></pre></div><p>With the help of two functors, <code>Identity</code> and <code>Const</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>newtype</span> <span style=color:#458;font-weight:700>Identity</span> a <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Identity</span> a
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Functor</span> <span style=color:#458;font-weight:700>Identity</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  fmap f (<span style=color:#458;font-weight:700>Identity</span> x) <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Identity</span> (f x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>newtype</span> <span style=color:#458;font-weight:700>Const</span> v a <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Const</span> v
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Functor</span> (<span style=color:#458;font-weight:700>Const</span> v) <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  fmap f (<span style=color:#458;font-weight:700>Const</span> x) <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Const</span> x
</span></span></code></pre></div><p>we can define:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>runIdentity</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Identity</span> s <span style=color:#000;font-weight:700>-&gt;</span> s
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>runIdentity</span> (<span style=color:#458;font-weight:700>Indentity</span> x) <span style=color:#000;font-weight:700>=</span> x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>getConst</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Const</span> v a <span style=color:#000;font-weight:700>-&gt;</span> v
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>getConst</span> (<span style=color:#458;font-weight:700>Const</span> x) <span style=color:#000;font-weight:700>=</span> x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>view</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Lens</span> s a <span style=color:#000;font-weight:700>-&gt;</span> (s <span style=color:#000;font-weight:700>-&gt;</span> a)
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>view</span> ln s <span style=color:#000;font-weight:700>=</span> getConst (ln <span style=color:#458;font-weight:700>Const</span> s)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>set</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Lens</span> s a <span style=color:#000;font-weight:700>-&gt;</span> (a <span style=color:#000;font-weight:700>-&gt;</span> s <span style=color:#000;font-weight:700>-&gt;</span> s)
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>set</span> ln x <span style=color:#000;font-weight:700>=</span> runIdentity <span style=color:#000;font-weight:700>.</span> ln (<span style=color:#458;font-weight:700>Identity</span> <span style=color:#000;font-weight:700>.</span> const x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>over</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Lens</span> s a <span style=color:#000;font-weight:700>-&gt;</span> ((a <span style=color:#000;font-weight:700>-&gt;</span> a) <span style=color:#000;font-weight:700>-&gt;</span> s <span style=color:#000;font-weight:700>-&gt;</span> s)
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>over</span> ln f <span style=color:#000;font-weight:700>=</span> runIdentity <span style=color:#000;font-weight:700>.</span> ln (<span style=color:#458;font-weight:700>Identity</span> <span style=color:#000;font-weight:700>.</span> f)
</span></span></code></pre></div><p>The advantage of this representation is that lens composition – e.g. combining the lens for an element of an inner structure with the lens for an element of the outer structure – is just function composition. It also sets the stage for another deep insight: if instead of a <em>Functor</em> we require an <em>Applicative</em>, we’ll get a multi-focus lens, i.e. a lens that can point to a number of elements at once. Magic.</p><p>Usefulness of lenses is not restricted to operating on nested records. Map lookup and update can be expressed as a lens, Edward’s library also provides lenses that e.g. allow access to individual bits of a piece of data.</p><p>In the talk Simon demonstrated that he can be just as enthusiastic about someone else’s work as he is about his own. While he did indicate that some of the aspects of the library seem obscure to him (“I wouldn’t write it point-free”, “I have no idea what this Prefunctor thing is!”), it was all good natured and highlighted an interesting difference between Haskell and Scala language stewardship: while Simon seemed genuinely thrilled that users of Haskell push the boundaries and use language features in previously unexpected ways, members of Typesafe team distance themselves from the FP part of the community and Martin Odersky <a href=https://twitter.com/odersky/status/382631339188428800>explicitly declared</a> his lack of interest in improving the experience of FP library writers.</p><h2 id=uniplate>Uniplate</h2><p><strong>Neil Mitchell</strong> explained how HLint benefits from the use of a generics library. HLint processes Haskell source code and provides hints on how to improve it by removing redundant bits, migrating off deprecated features and making it more idiomatic. As such, the tool relies on traversing AST of the Haskell module being analysed (the AST is provided by functions in <code>haskell-src-exts</code> package) and while doing so applying a set of rules. Given that in the AST <code>Decl</code> has 27, <code>Exp</code> has 45 and <code>Pat</code> has 23 constructors writing each rule for each of these cases would require lots of boilerplate code.</p><p>This is where generics libraries come into the picture. Their purpose is to abstract away the traversal code so that the logic can be stated in terms of the usual pattern and exceptions from that pattern. Uniplate is one such library. It provides four functions that operate on instances of <code>Uniplate</code> type class:</p><table><thead><tr><th>\</th><th>Query</th><th>Transform</th></tr></thead><tbody><tr><td><strong>Deep</strong></td><td>universe</td><td>transform</td></tr><tr><td><strong>Shallow</strong></td><td>children</td><td>descend</td></tr></tbody></table><p>The use of these is prehaps best illustrated by examples from HLint:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>transform</span> <span style=color:#000;font-weight:700>::</span> (on <span style=color:#000;font-weight:700>-&gt;</span> on) <span style=color:#000;font-weight:700>-&gt;</span> on <span style=color:#000;font-weight:700>-&gt;</span> on
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- eliminate redundant parentheses</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>lessParen</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Exp</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Exp</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>lessParen</span> <span style=color:#000;font-weight:700>=</span> transform f
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>where</span> f (<span style=color:#458;font-weight:700>Paren</span> (<span style=color:#458;font-weight:700>Paren</span> x)) <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Paren</span> x
</span></span><span style=display:flex><span>        f (<span style=color:#458;font-weight:700>Paren</span> (<span style=color:#458;font-weight:700>List</span> x))  <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>List</span> x
</span></span><span style=display:flex><span>        f x                 <span style=color:#000;font-weight:700>=</span> x
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>universe</span> <span style=color:#000;font-weight:700>::</span> on <span style=color:#000;font-weight:700>-&gt;</span> [on]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- determine if a language extension is used</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>redundantExtension</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Module</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Bool</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>redundantExtension</span> m <span style=color:#000;font-weight:700>=</span>
</span></span><span style=display:flex><span>  viewPats <span style=color:#000;font-weight:700>==</span> <span style=color:#099>0</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> <span style=color:#d14>&#34;ViewPatterns&#34;</span> `elem` exts
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>    viewPats <span style=color:#000;font-weight:700>=</span> length[<span style=color:#0086b3>()</span> <span style=color:#000;font-weight:700>|</span> <span style=color:#458;font-weight:700>PViewPat</span> {} <span style=color:#000;font-weight:700>&lt;-</span> universeBi m]
</span></span><span style=display:flex><span>    exts <span style=color:#000;font-weight:700>=</span> [prettyPrint x <span style=color:#000;font-weight:700>|</span> <span style=color:#458;font-weight:700>LanguagePragma</span> <span style=color:#000;font-weight:700>_</span> xs <span style=color:#000;font-weight:700>&lt;-</span> universeBi m, x <span style=color:#000;font-weight:700>&lt;-</span> xs]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>descend</span> <span style=color:#000;font-weight:700>::</span> (on <span style=color:#000;font-weight:700>-&gt;</span> on) <span style=color:#000;font-weight:700>-&gt;</span> on <span style=color:#000;font-weight:700>-&gt;</span> on
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- eliminate conditionals with constant condition</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>eval</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Exp</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Exp</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>eval</span> x <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>case</span> x <span style=color:#000;font-weight:700>of</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Lambda</span>{} <span style=color:#000;font-weight:700>-&gt;</span> x
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>If</span> c t f <span style=color:#000;font-weight:700>|</span> prettyPrint c <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#34;True&#34;</span> <span style=color:#000;font-weight:700>-&gt;</span> eval t
</span></span><span style=display:flex><span>           <span style=color:#000;font-weight:700>|</span> prettyPrint c <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#34;False&#34;</span> <span style=color:#000;font-weight:700>-&gt;</span> eval f
</span></span><span style=display:flex><span>  x <span style=color:#000;font-weight:700>-&gt;</span> descend eval x
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>children</span> <span style=color:#000;font-weight:700>::</span> on <span style=color:#000;font-weight:700>-&gt;</span> [on]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- find the names of all free variables</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>freeVars</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Exp</span> <span style=color:#000;font-weight:700>-&gt;</span> [<span style=color:#458;font-weight:700>String</span>]
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>freeVars</span> (<span style=color:#458;font-weight:700>Var</span> x) <span style=color:#000;font-weight:700>=</span> [prettyPrint x]
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>freeVars</span> (<span style=color:#458;font-weight:700>Lambda</span> <span style=color:#000;font-weight:700>_</span> x bod) <span style=color:#000;font-weight:700>=</span> freeVars bod <span style=color:#000;font-weight:700>\\</span> boundVars x
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>freeVars</span> x <span style=color:#000;font-weight:700>=</span> nub <span style=color:#000;font-weight:700>$</span> concatMap freeVars <span style=color:#000;font-weight:700>$</span> children x
</span></span></code></pre></div><p>How are these functions implemented? <code>universe</code> and <code>transform</code> can be implemented in terms of the shallow primitives that give more control:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>universe</span> x <span style=color:#000;font-weight:700>=</span> x <span style=color:#458;font-weight:700>:</span> concatMap universe (children x)
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>transform</span> f <span style=color:#000;font-weight:700>=</span> f <span style=color:#000;font-weight:700>.</span> descend (transform f)
</span></span></code></pre></div><p><code>children</code> and <code>descend</code> rely on an instance of <code>Uniplate</code> type class for the type they are to operate on – <code>Exp</code> in the case of the examples above:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>Uniplate</span> on <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  uniplate <span style=color:#000;font-weight:700>::</span> on <span style=color:#000;font-weight:700>-&gt;</span> ([on],       <span style=color:#998;font-style:italic>-- children</span>
</span></span><span style=display:flex><span>                     [on] <span style=color:#000;font-weight:700>-&gt;</span> on) <span style=color:#998;font-style:italic>-- a fn that puts the children together back into the parent</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Uniplate</span> <span style=color:#458;font-weight:700>Exp</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  uniplate (<span style=color:#458;font-weight:700>App</span> x y) <span style=color:#000;font-weight:700>-</span> ([x,y], <span style=color:#900;font-weight:700>\</span>[x,y] <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>App</span> x y)
</span></span><span style=display:flex><span>  <span style=color:#998;font-style:italic>-- and so on for all other type constructors</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>children</span> <span style=color:#000;font-weight:700>=</span> fst <span style=color:#000;font-weight:700>.</span> uniplate
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>descend</span> f x <span style=color:#000;font-weight:700>=</span> gen <span style=color:#000;font-weight:700>$</span> map f cs
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>where</span> (cs, gen) <span style=color:#000;font-weight:700>=</span> uniplate x
</span></span></code></pre></div><p>This means all constructors need to be handled just in a single place, when the type class instace is defined, and from then on generic type traversal functions can be used. While there is a number of other generic programming solutions out there, notably <code>GHC.Generics</code> and <code>Data.Data</code>, Uniplate is simple, concise and performant.</p><h2 id=free-monads>Free Monads</h2><p>According to <strong>Andres Löh</strong>, everything is an EDSL. Even though some things don’t look like this on the first sight, they usually greatly benefit from language-like treatment, so over time we have seen DSLs taking over domains such as parsing, GPU computations and music. When developing an EDSL it is preferable to embed it deeply, i.e. be able to treat the program as data in the host language, so that it can be inspected, transformed and interpreted in various ways. Andres illustrated an evolution of a very simple, imperative language, from a shallow embedding to a deep embedding and the abstract constructs that could be extracted from that exercise. I am going to repeat all the steps of this derivation as it is very educational.</p><p>If our language provided just two constructs, <code>say</code> and <code>ask</code>, we could write a program in it like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>do</span>
</span></span><span style=display:flex><span>  say <span style=color:#d14>&#34;What&#39;s your name?&#34;</span>
</span></span><span style=display:flex><span>  name <span style=color:#000;font-weight:700>&lt;-</span> ask
</span></span><span style=display:flex><span>  say (<span style=color:#d14>&#34;Hello &#34;</span> <span style=color:#000;font-weight:700>++</span> name)
</span></span></code></pre></div><p>and implement it, via shallow embedding, like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>say</span> <span style=color:#000;font-weight:700>=</span> putStrLn
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>ask</span> <span style=color:#000;font-weight:700>=</span> getLine
</span></span></code></pre></div><p>This works, but does not bring the benefits associated with deep embedding. To realise them we have to model our language as a data type and execute the code above in a custom monad:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Interaction</span> a
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Monad</span> <span style=color:#458;font-weight:700>Interaction</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>say</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>ask</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#458;font-weight:700>String</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Say</span>    <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Ask</span>    <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#458;font-weight:700>String</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Return</span> <span style=color:#000;font-weight:700>::</span> a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> a
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Bind</span>   <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Interaction</span> a <span style=color:#000;font-weight:700>-&gt;</span> (a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> b) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Monad</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  return <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Return</span>
</span></span><span style=display:flex><span>  (<span style=color:#000;font-weight:700>&gt;&gt;=</span>) <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Bind</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>run</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Interaction</span> a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>IO</span> a
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>run</span> (<span style=color:#458;font-weight:700>Say</span> s)    <span style=color:#000;font-weight:700>=</span> putStrLn s
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>run</span> <span style=color:#458;font-weight:700>Ask</span>        <span style=color:#000;font-weight:700>=</span> getLine
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>run</span> (<span style=color:#458;font-weight:700>Return</span> x) <span style=color:#000;font-weight:700>=</span> return x
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>run</span> (<span style=color:#458;font-weight:700>Bind</span> i f) <span style=color:#000;font-weight:700>=</span> (run i) <span style=color:#000;font-weight:700>&gt;&gt;=</span> (run <span style=color:#000;font-weight:700>.</span> f)
</span></span></code></pre></div><p>This is going to work, but sadly, <code>Interaction</code> is not really a monad, as it does not abide by the monad laws. Since <code>return</code> and <code>>>=</code> just wrap the arguments in further layers of constructors, e.g. left associatvity law (<code>return x >>= f</code> must equal <code>f x</code>) is violated: <code>Bind (Return x) f</code> is not the same as <code>f x</code>. One could argue that as long as the interpretation functions preserve this property we are good, but it is a tricky argument to make and it’s much preferable to guarantee good behaviour by construction.</p><p>To achieve this we can first observe that by the monad laws every monadic computation has a normal form which consists of a sequence of atomic operations followed by a single <code>return</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>do</span>
</span></span><span style=display:flex><span>  x1 <span style=color:#000;font-weight:700>&lt;-</span> step1
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>..</span>
</span></span><span style=display:flex><span>  xn <span style=color:#000;font-weight:700>&lt;-</span> stepn
</span></span><span style=display:flex><span>  return something
</span></span></code></pre></div><p>so a way to guarantee conformance of our monad to the laws would be to construct it so that it represents such a normalised computation. Our language consists of two atomic operations, <code>Say</code> and <code>Ask</code>, so all we need to do is guarantee that <code>Bind</code> can only operate on one of these two. To guarantee that, let’s replace it with its partial applications to the two atomic commands:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>say&#39;</span> msg <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Bind</span> (<span style=color:#458;font-weight:700>Say</span> msg)
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>ask&#39;</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Bind</span> <span style=color:#458;font-weight:700>Ask</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Return</span> <span style=color:#000;font-weight:700>::</span> a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> a
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Say&#39;</span>   <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> (<span style=color:#0086b3>()</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> b) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> b
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Ask&#39;</span>   <span style=color:#000;font-weight:700>::</span> (<span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> b) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> b
</span></span></code></pre></div><p>This is still an instance of a monad:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Monad</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  return <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Return</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Return</span> x   <span style=color:#000;font-weight:700>&gt;&gt;=</span> f <span style=color:#000;font-weight:700>=</span> f x
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Say&#39;</span> msg k <span style=color:#000;font-weight:700>&gt;&gt;=</span> f <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Say&#39;</span> msg ((<span style=color:#000;font-weight:700>&gt;&gt;=</span> f) <span style=color:#000;font-weight:700>.</span> k)
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Ask&#39;</span> k     <span style=color:#000;font-weight:700>&gt;&gt;=</span> f <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Ask&#39;</span> ((<span style=color:#000;font-weight:700>&gt;&gt;=</span> f) <span style=color:#000;font-weight:700>.</span> k)
</span></span></code></pre></div><p>Furthermore, it now fulfills the laws, and the interpreter is still straightforward:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>run</span> (<span style=color:#458;font-weight:700>Return</span> x) <span style=color:#000;font-weight:700>=</span> return x
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>run</span> (<span style=color:#458;font-weight:700>Say&#39;</span> msg k) <span style=color:#000;font-weight:700>=</span> putStrLn msg <span style=color:#000;font-weight:700>&gt;&gt;=</span> run <span style=color:#000;font-weight:700>.</span> k
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>run</span> (<span style=color:#458;font-weight:700>Ask&#39;</span> k) <span style=color:#000;font-weight:700>=</span> readLn <span style=color:#000;font-weight:700>&gt;&gt;=</span> run <span style=color:#000;font-weight:700>.</span> k
</span></span></code></pre></div><p>With this sorted out we can now think about how to extract the underlying pattern into something reusable. A good place to start would be splitting the construct into two parts: the generic monad that describes normal form and the set of concrete atomic operations, <code>InteractionOp</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Interaction</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Return</span> <span style=color:#000;font-weight:700>::</span> a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> a
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Wrap</span>   <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>InteractionOp</span> a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>InteractionOp</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Say&#39;</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> (<span style=color:#0086b3>()</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> b) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>InteractionOp</span> b
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Ask&#39;</span> <span style=color:#000;font-weight:700>::</span> (<span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Interaction</span> b) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>InteractionOp</span> b
</span></span></code></pre></div><p>The type variable <code>b</code> is only used as the argument to <code>Interaction</code>, so without any loss of generality <code>Interaction b</code> can be replaced by a single variable <code>r</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>InteractionOp</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Say&#39;</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> (<span style=color:#0086b3>()</span> <span style=color:#000;font-weight:700>-&gt;</span> r) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>InteractionOp</span> r
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Ask&#39;</span> <span style=color:#000;font-weight:700>::</span> (<span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> r) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>InteractionOp</span> r
</span></span></code></pre></div><p>Finally, we break <code>Interaction</code> free from <code>InteractionOp</code> by parameterising it by the data type it will operate on, at the same time renaming it to <code>Free</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Free</span> <span style=color:#000;font-weight:700>::</span> (<span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span>) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Return</span> <span style=color:#000;font-weight:700>::</span> a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Free</span> f a
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Wrap</span>   <span style=color:#000;font-weight:700>::</span> f (<span style=color:#458;font-weight:700>Free</span> f a) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Free</span> f a
</span></span></code></pre></div><p>When is <code>Free</code> a monad? Definitely, whenever <code>f</code> is a functor:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Functor</span> f <span style=color:#000;font-weight:700>=&gt;</span> <span style=color:#458;font-weight:700>Monad</span> (<span style=color:#458;font-weight:700>Free</span> f) <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  return <span style=color:#000;font-weight:700>::</span> a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Free</span> f a
</span></span><span style=display:flex><span>  return <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#000;font-weight:700>&gt;&gt;=</span>) <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Free</span> f a <span style=color:#000;font-weight:700>-&gt;</span> (a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Free</span> f b) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Free</span> f b
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Return</span> x <span style=color:#000;font-weight:700>&gt;&gt;=</span> f <span style=color:#000;font-weight:700>=</span> f x
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Wrap</span> c   <span style=color:#000;font-weight:700>&gt;&gt;=</span> f <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Wrap</span> (fmap (<span style=color:#000;font-weight:700>&gt;&gt;=</span> f) c)
</span></span></code></pre></div><p>What remains to be shown is that <code>InteractionOp</code> is a functor, which is left as an exercise for the reader.</p><p>What have we achieved here? Given a functor we get a monad for free! It turns out that many well known monads, such as <em>Identity</em> and <em>Maybe</em>, are isomorphic to a free monad. But primarily, we’ve defined a flexible scheme for writing deeply embedded EDSLs. The power of this construct can be witnessed in this example of a custom scheduler for a simple concurrent process language:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>ProcessF</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>*</span> <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Atomically</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>IO</span> a <span style=color:#000;font-weight:700>-&gt;</span> (a <span style=color:#000;font-weight:700>-&gt;</span> r) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>ProcessF</span> r
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>Fork</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Process</span> <span style=color:#0086b3>()</span> <span style=color:#000;font-weight:700>-&gt;</span> r <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>ProcessF</span> r
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#458;font-weight:700>Process</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Free</span> <span style=color:#458;font-weight:700>ProcessF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>atomically</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>IO</span> a <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Process</span> a
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>atomically</span> m <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Wrap</span> (<span style=color:#458;font-weight:700>Atomically</span> m <span style=color:#458;font-weight:700>Return</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>fork</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Process</span> <span style=color:#0086b3>()</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Process</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>fork</span> p <span style=color:#000;font-weight:700>-</span> <span style=color:#458;font-weight:700>Wrap</span> (<span style=color:#458;font-weight:700>Fork</span> p (<span style=color:#458;font-weight:700>Return</span> <span style=color:#0086b3>()</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- we can define the scheduling however we want!</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>schedule</span> <span style=color:#000;font-weight:700>::</span> [<span style=color:#458;font-weight:700>Process</span> <span style=color:#0086b3>()</span>] <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>IO</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>schedule</span> <span style=color:#458;font-weight:700>[]</span>                         <span style=color:#000;font-weight:700>=</span> return <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>schedule</span> (<span style=color:#458;font-weight:700>Return</span> <span style=color:#000;font-weight:700>_</span> <span style=color:#458;font-weight:700>:</span> ps)            <span style=color:#000;font-weight:700>=</span> schedule ps
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>schedule</span> (<span style=color:#458;font-weight:700>Wrap</span> (<span style=color:#458;font-weight:700>Atomically</span> m k)<span style=color:#458;font-weight:700>:</span>ps) <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>do</span>
</span></span><span style=display:flex><span>                                        x <span style=color:#000;font-weight:700>&lt;-</span> m
</span></span><span style=display:flex><span>                                        schedule (ps <span style=color:#000;font-weight:700>++</span> [k x])
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>schedule</span> (<span style=color:#458;font-weight:700>Wrap</span> (<span style=color:#458;font-weight:700>Fork</span> p1 p2) <span style=color:#458;font-weight:700>:</span> ps)   <span style=color:#000;font-weight:700>=</span> schedule (ps <span style=color:#000;font-weight:700>++</span> [p2, p1])
</span></span></code></pre></div><p>I recommend as an exercise implementing a simple program that uses <code>atomically</code> and <code>fork</code>, run it through <code>schedule</code> and see what comes out; then experimenting with other implementations of <code>schedule</code>.</p><h2 id=other-talks>Other Talks</h2><p>EDSLs were definitely a big theme of the day, with <strong>Gracjan Polak</strong> and <strong>Bas van Dijk</strong> describing how they naturally evolved in the course of hacking at the start-ups they are involved in (Scrive and Erudify, respectively). <strong>Simon Marlow</strong> related how Haskell’s support for abstracting the execution details makes writing spam detection rules easier at another “small Haskell startup” (Facebook). <strong>Adam Bergmark</strong> talked about JavaScript related woes of web startup life and how Fay, a Haskell to JavaScript compiler, addresses them. Finally, in a park bench discussion, the panelists broadely agreed that hiring Haskell developers is easy and the quality of candidates is excellent. There was a disagreement though on laziness vs. strictness and on whether the programmers need to be aware of the evaluation strategy.</p></main><p class=date>2013/10/09</p><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2022. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>