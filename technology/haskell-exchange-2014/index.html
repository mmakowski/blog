<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Haskell Exchange 2014 | Maciek's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/blog/technology/>Tech</a></li><li><a href=/blog/travel/>Travel</a></li><li><a href=/blog/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Haskell Exchange 2014</span></h1><h2 class=date>2014/10/08</h2></div><main><p>I was surprised to find that despite all-star line-up of speakers, this year’s Haskell Exchange was not as well attended and lower key than the <a href=http://mmakowski.github.io/blog/technology/haskell-exchange-2013/>2013 edition</a>. We were back to SkillsMatter headquarters, this time round with gym music blasting from the speakers during breaks and with no aircon for added frowziness. The talks were good though, some of them very much so.</p><h2 id=safe-zero-cost-coercions-in-haskell>Safe, Zero-Cost Coercions in Haskell</h2><p><strong>Simon Peyton-Jones</strong> arrived bare-footed and dispelled one of the illusions I have been holding on to for quite a while, that the minimal core language of GHC, System FC, is sound beyond any reasonable doubt. After all, hasn’t this soundness been proven in peer-reviewed papers? It has, but even in the intellectually astute and pure realms of Haskell, adding new, seemingly innocent feature such as <code>newtype</code> can lead to catastrophic consequences. In this case it was <a href=https://ghc.haskell.org/trac/ghc/ticket/1496>GHC bug #1496</a>, which demonstrated how generalised newtype deriving coupled with type families can lead to GHC producing code that segfaults. This has been a source of great embarassment for Simon and took seven years to sort out. The solution relies on restricting under what circumstances type coercions can be performed. First, there is a new built-in type class introduced in GHC, alongside with a function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>Coercible</span> a b
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>coerce</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Coercible</span> a b <span style=color:#000;font-weight:700>=&gt;</span> a <span style=color:#000;font-weight:700>-&gt;</span> b
</span></span></code></pre></div><p><code>Coercible a b</code> instance indicates that the runtime representation of values of type <code>a</code> is identical to that of values of type <code>b</code>, so no work needs to be done when converting from one to the other. Instances of this class are auto-generated by GHC for custom data types and newtypes, for example</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>newtype</span> <span style=color:#458;font-weight:700>HTML</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>MkHTML</span> <span style=color:#458;font-weight:700>String</span>
</span></span></code></pre></div><p>will lead to generation of</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Coercible</span> <span style=color:#458;font-weight:700>HTML</span> <span style=color:#458;font-weight:700>String</span>
</span></span></code></pre></div><p><code>coerce</code> does not introduce any runtime code, but can be invoked by the programmer to transform data between types. Lifting instances, such as</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>Coercible</span> a <span style=color:#000;font-weight:700>=&gt;</span> <span style=color:#458;font-weight:700>Coercible</span> [a]
</span></span></code></pre></div><p>are also generated for parameterised types, including user-defined types. Therein lies a problem:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>newtype</span> <span style=color:#458;font-weight:700>HTML</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Mk</span> <span style=color:#458;font-weight:700>String</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#000;font-weight:700>family</span> <span style=color:#458;font-weight:700>F</span> a
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>F</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Char</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#000;font-weight:700>instance</span> <span style=color:#458;font-weight:700>F</span> <span style=color:#458;font-weight:700>HTML</span>   <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Tricky</span> a <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>MkT</span> a (<span style=color:#458;font-weight:700>F</span> a)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>veryNaughty</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Tricky</span> <span style=color:#458;font-weight:700>String</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Tricky</span> <span style=color:#458;font-weight:700>HTML</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>veryNaughty</span> ts <span style=color:#000;font-weight:700>=</span> coerce ts
</span></span></code></pre></div><p>What would <code>coerce</code> do to the second type argument, which in <code>Tricky String</code> is <code>Char</code> but in <code>Tricky HTML</code> should be a <code>Bool</code>? This is where the unsoundness stems from. To address this, a new concept needs to be introduced: roles of types parameters. There are three possible roles:</p><ul><li>representational – not used in a type-function argument</li><li>nominal – used in type function argument</li><li>phantom – the argument does not appera at all</li></ul><p>Nominal parameters should not lead to type instance generation. For example, in:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#000;font-weight:700>family</span> <span style=color:#458;font-weight:700>F</span> a
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- instances ..</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>T</span> a b c <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>T1</span> b (<span style=color:#458;font-weight:700>F</span> a)
</span></span><span style=display:flex><span>             <span style=color:#000;font-weight:700>|</span> <span style=color:#458;font-weight:700>T2</span> a b
</span></span></code></pre></div><p><code>T</code> would have <code>instance Coercible b b' => Coercible (T a b c) (T a b' c')</code> lifting generated for it, but not <code>instance Coercible a a' => Coercible (T a b c) (T a' b c')</code>. Roles can be inferred, but if a restriction is desirable they can be specified explicitly using syntax</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> role <span style=color:#458;font-weight:700>Map</span> nominal <span style=color:#000;font-weight:700>_</span>
</span></span></code></pre></div><p>where we say that the role of first type argument to <code>Map</code> is nominal and the second should be inferred. This specific example is actually useful, because for <code>Map</code> the internal layout is determined by the ordering of keys (i.e. <code>Ord</code> instance for the first type parameter), and that could change under coercion to a newtype! Lennart Augustsson pointed out that the necessity to write these can lead to buggy code – an assertion difficult to debunk. Another drawback to which Lennart drew attention was that the current scheme does not work for higher-kinded types.</p><p>While Simon argued that nothing simpler than roles can give sound account of type functions, the talk served as a useful reminder that even such rigorously developed and internally simple languages as Haskell suffer from the complexity that software developers require from their tools. After all, newtypes, type families and so on were introduced to address genuine engineering challenges.</p><h2 id=categories-for-the-working-haskeller>Categories for the Working Haskeller</h2><p>We all now know what a functor is. An <em>algebra</em> for functor <code>F</code> is a pair <code>(F, f)</code> where <code>f :: F B -> B</code>. A <em>homomorphism</em> between <code>(B, f)</code> and <code>(C, g)</code> is a function <code>h :: B -> C</code> such that the following diagram commutes:</p><pre tabindex=0><code>digraph m {
node[shape=none,fontcolor=&#34;#657b83&#34;];
edge[color=&#34;#657b83&#34;,fontcolor=&#34;#657b83&#34;];
bgcolor=transparent;
rankdir=LR;
&#34;F B&#34; -&gt; B [label=f];
&#34;F C&#34; -&gt; C [label=g];
&#34;F B&#34; -&gt; &#34;F C&#34; [label=&#34;F h&#34;];
B -&gt; C [label=h];
{rank=same &#34;F B&#34; &#34;F C&#34;}
{rank=same B C}
}
</code></pre><p>Algebra <code>(B, f)</code> is <em>initial</em> if there is a unique homomorphism from it to each <code>(C, g)</code>.</p><p>How does this help? <strong>Jeremy Gibbons</strong> argued that it allows for construction of elegant APIs – mostly as an inspiration, mind you, not the end product that users look at. Take folds over a list as an example. <code>foldr :: (a -> b -> b) -> b -> [a] -> b</code> function encodes a certain traversal scheme for lists, but if we want a similar type of collapsing performed on our custom data type, a binary tree for example, we are on our own. Or are we?</p><p>First, we can separate two concerns in the data type definition: one that specifies the shape, the other that it’s a recursive data type. For a list it can be done as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>ListS</span> a b <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>NilS</span> <span style=color:#000;font-weight:700>|</span> <span style=color:#458;font-weight:700>ConsS</span> a b <span style=color:#998;font-style:italic>-- shape</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Fix</span> s a <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>In</span> (s a (<span style=color:#458;font-weight:700>Fix</span> s a)) <span style=color:#998;font-style:italic>-- recursion</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#458;font-weight:700>List</span> a <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Fix</span> <span style=color:#458;font-weight:700>ListS</span> a         <span style=color:#998;font-style:italic>-- put together</span>
</span></span></code></pre></div><p>Here, list <code>[1,2,3]</code> would be represented by <code>In (ConsS 1 (In (ConsS 2 (In (ConsS 3 (In NilS))))))</code>. As <code>ListS</code> has two type parameters (the type of element and the type of the tail), we can construct a “double map” or (bimap) function that will map over both of them:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>bimap</span> <span style=color:#000;font-weight:700>::</span> (a <span style=color:#000;font-weight:700>-&gt;</span> a&#39;) <span style=color:#000;font-weight:700>-&gt;</span> (b <span style=color:#000;font-weight:700>-&gt;</span> b&#39;) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>ListS</span> a b <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>ListS</span> a&#39; b&#39;
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>bimap</span> f g <span style=color:#458;font-weight:700>NilS</span>        <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>NilS</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>bimap</span> f g (<span style=color:#458;font-weight:700>ConsS</span> a b) <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>ConsS</span> (f a) (g b)
</span></span></code></pre></div><p>and implement a fold using it:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>foldList</span> <span style=color:#000;font-weight:700>::</span> (<span style=color:#458;font-weight:700>ListS</span> a b <span style=color:#000;font-weight:700>-&gt;</span> b) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>List</span> a <span style=color:#000;font-weight:700>-&gt;</span> b
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>foldList</span> <span style=color:#000;font-weight:700>=</span> f <span style=color:#000;font-weight:700>.</span> bimap id (foldList f) <span style=color:#000;font-weight:700>.</span> out
</span></span></code></pre></div><p>This seems overly complicated, but lets us generalise beyond lists to other shapes:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>Bifunctor</span> s <span style=color:#000;font-weight:700>where</span>
</span></span><span style=display:flex><span>  bimap <span style=color:#000;font-weight:700>::</span> (a <span style=color:#000;font-weight:700>-&gt;</span> a&#39;) <span style=color:#000;font-weight:700>-&gt;</span> (b <span style=color:#000;font-weight:700>-&gt;</span> b&#39;) <span style=color:#000;font-weight:700>-&gt;</span> s a b <span style=color:#000;font-weight:700>-&gt;</span> s a&#39; b&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>out</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Fix</span> s a <span style=color:#000;font-weight:700>-&gt;</span> s a (<span style=color:#458;font-weight:700>Fix</span> s a)
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>out</span> (<span style=color:#458;font-weight:700>In</span> x) <span style=color:#000;font-weight:700>=</span> x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>fold</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Bifunctor</span> s <span style=color:#000;font-weight:700>=&gt;</span> (s a b <span style=color:#000;font-weight:700>-&gt;</span> b) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Fix</span> s a <span style=color:#000;font-weight:700>-&gt;</span> b
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>fold</span> f <span style=color:#000;font-weight:700>=</span> f <span style=color:#000;font-weight:700>.</span> bimap id (fold f) <span style=color:#000;font-weight:700>.</span> out
</span></span></code></pre></div><p>Why <em>Bifunctor</em>? Because it’s a functor in both type arguments. That means that <code>ListS Integer</code> is a functor. Furthermore, <code>(List Integer, In)</code>, <code>(Integer, add)</code> are some of its algebras:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#458;font-weight:700>In</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ListS</span> <span style=color:#458;font-weight:700>Integer</span> (<span style=color:#458;font-weight:700>List</span> <span style=color:#458;font-weight:700>Integer</span>) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>List</span> <span style=color:#458;font-weight:700>Integer</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>add</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ListS</span> <span style=color:#458;font-weight:700>Integer</span> <span style=color:#458;font-weight:700>Integer</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Integer</span>
</span></span></code></pre></div><p>and <code>sum :: List Integer -> Integer</code> is a homomorphism for these two. Furthermore, <code>(List Integer, In)</code> is the initial algebra for <code>ListS Integer</code>, and the unique homomorphism to a given <code>(C, g)</code> is <code>fold g</code>. The commuting of the diagram translates to condition <code>h . f = g . bimap id h</code>. Categorical duality gives us the morphisms in opposite direction (unfolding) virtually for free and in a from that makes the duality obvious:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>unfold</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Bifunctor</span> s <span style=color:#000;font-weight:700>-&gt;</span> (b <span style=color:#000;font-weight:700>-&gt;</span> s a b) <span style=color:#000;font-weight:700>-&gt;</span> (b <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Fix</span> s a)`
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>unfold</span> f <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>In</span> <span style=color:#000;font-weight:700>.</span> bimap id (unfold f) <span style=color:#000;font-weight:700>.</span> f
</span></span></code></pre></div><p>What’s best, we can apply this to all types that can be represented using unfixed shape functor. Yay. That’s what Tony Morris calls “taking DRY principle seriously”.</p><p>Jeremy recommended we check out the <a href=https://www.cs.ox.ac.uk/softeng/>MSc course in Software Engineering offered by Oxford University</a>. I definitely will take a close look.</p><h2 id=performance-measurement-and-optimisation-in-haskell>Performance Measurement and Optimisation in Haskell</h2><p>There are more ways to screw up microbenchmarking than one can list in three quarters of an hour, and there is a solution to them that fits in two words: use <a href=http://www.serpentine.com/criterion/>criterion</a>. <strong>Bryan O’Sullivan</strong> borrowed ideas from leading tools to put together something that is easy to use and accurate. Always wanted to benchmark that dodgy <code>fib 1 = 1; fib 2 = 1; fib n = fib (n - 1) + fib (n - 2)</code>? There you go:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>Criterion.Main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>main</span> <span style=color:#000;font-weight:700>=</span> defaultMain [
</span></span><span style=display:flex><span>  bgroup <span style=color:#d14>&#34;fib&#34;</span> [ bench <span style=color:#d14>&#34;1&#34;</span> <span style=color:#000;font-weight:700>$</span> whnf fib <span style=color:#099>1</span>
</span></span><span style=display:flex><span>               , bench <span style=color:#d14>&#34;5&#34;</span> <span style=color:#000;font-weight:700>$</span> whnf fib <span style=color:#099>5</span>
</span></span><span style=display:flex><span>               , bench <span style=color:#d14>&#34;9&#34;</span> <span style=color:#000;font-weight:700>$</span> whnf fib <span style=color:#099>9</span>
</span></span><span style=display:flex><span>               ]]
</span></span></code></pre></div><p>Criterion will take care that the thunk gets evaluated in every benchmark iteration, will detect how noisy the system is, produce kernel density estimate, use ordinary least-squares regression to factor out the cost of time measurements themselves and generate nice HTML reports with graphs and all – all this while making sure that you don’t forget that performance measurement is a statistical activity and you should get used to working with distributions rather than single statistics such as mean or median.</p><p>Finally, Bryan’s pro tips for performance optimisation:</p><ul><li>keep overhead of data types in mind</li><li>keep uses of your data in mind – e.g., can we stream or do we have to consume all?</li><li>keep strictness of code and data in mind – neither strictness nor laziness is always appropriate.</li></ul><h2 id=rest---building-apis-easily>Rest - Building APIs Easily</h2><p><strong>Erik Hasselink</strong> kicked off the industrial afternoon with an overview of <em>Rest</em>, a library for (you guessed it) writing RESTful web services that has recently been <a href=https://github.com/silkapp/rest>open sourced</a> by his company, Silk. While to code snippets presented by Erik did not seem overly exciting, what was impressive was the list of features provided by the library, chief among them generation of client libraries in Haskell in Javascript, so that you can start using your service from a separate app without writing any additional code. The library is web framework agnostic and Silk wrote bindings for Happstack, Snap and WAI.</p><h2 id=coping-with-change-data-schema-migration-in-haskell>Coping with Change: Data Schema Migration in Haskell</h2><p><strong>Chris Dornan</strong> and <strong>Adam Gundry</strong> took on a task of migrating a video sharing platform implemented in Ruby onto a new software stack. One of the main challenges is the requirement to carry on migrating data as the software undergoes active development. To that end a schema description DSL has been devised:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>ur</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>User</span> <span style=color:#000;font-weight:700>=</span> record
</span></span><span style=display:flex><span>           <span style=color:#000;font-weight:700>|</span> name <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>NAme</span>
</span></span><span style=display:flex><span>           <span style=color:#000;font-weight:700>|</span> admin <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>AdminType</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>nm</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Name</span> <span style=color:#000;font-weight:700>=</span> basic <span style=color:#458;font-weight:700>String</span>
</span></span></code></pre></div><p>This is used for describing both the data written to persistent stores and the communication protocol. To support migration of data this has been extended with human- and machine-readable change logs:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>ur</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>User</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>=</span> record
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>|</span> name <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Name</span>
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>|</span> admin <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Admin</span> <span style=color:#458;font-weight:700>Type</span>
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>|</span> password <span style=color:#000;font-weight:700>::</span> <span style=color:#000;font-weight:700>?</span> <span style=color:#458;font-weight:700>Password</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>changes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  version <span style=color:#d14>&#34;0.2&#34;</span>
</span></span><span style=display:flex><span>    changed record <span style=color:#458;font-weight:700>User</span>
</span></span><span style=display:flex><span>      field added password <span style=color:#000;font-weight:700>::</span> <span style=color:#000;font-weight:700>?</span> <span style=color:#458;font-weight:700>Password</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  version <span style=color:#d14>&#34;0.1&#34;</span>
</span></span></code></pre></div><p>The build process verifies that the change log is in sync with the entity definition. Rollbacks are not currently supported but are on Adam and Chris’s agenda.</p><h2 id=structural-typing-for-structured-products>Structural Typing for Structured Products</h2><p>This talk made me sad. <strong>Peter Marks</strong> and <strong>Tim Williams</strong> described <em>FPF Lucid</em>, a DSL they are developing at Barclays for describing payoffs of exotic equity derivatives. A Lucid function looks like this:</p><pre tabindex=0><code>function capFloor(perf, {cap, floor})
  return max(floor, min(cap, perf))
end
</code></pre><p>and its type inferred by the compiler is</p><pre tabindex=0><code>capFloor: Num a =&gt; (a, {cap: a, floor: a|r}) -&gt; a
</code></pre><p>where <code>r</code> is row variable, indicating possible other fields of the record. Users of the language don’t have to specify any types and can use records of different shapes as inputs to the same function as long as the records contain required fields – i.e. the typing is structural, not nominal. This gives the language a “dynamic” feel, like coding in Python or Ruby, but with the benefits of comprehensive compile-time type checking.</p><p>Designing and implementing a programming language, with full Hindley-Milner type inference involving structural types and row polymorphism, incorporating some cutting-edge programming language research results, coding in Haskell, all that in perhaps a non-ideal, but familiar banking environment, with direct influence on the company’s competitive advantage, sounded close to a dream job. And to think that I spent over a year lurking in FPF team’s chat channel and did not work up the nerve to speak to them and ask if they had any openings before deciding on leaving Barclays for good…</p><h2 id=strongly-typed-publishsubscribe-over-websockets-via-singleton-types>Strongly Typed Publish/Subscribe over WebSockets via Singleton Types</h2><p>Like Erik, <strong>Oliver Charles</strong> works on web APIs. In his case the focus was not on REST though, but on subscription channels implemented over WebSockets. The challenge there was ensuring that the server-side implementation of <a href=http://socket.io>Socket.IO</a> protocol is reliable. To that end relying on strings as event representation was not good enough, as it did not guarantee that the correct type of data was being sent for a given subscription. It has been too late in the day for me to comprehend all of the details of the solution, but in short, combining <code>GADTs</code>, <code>TypeFamilies</code> and <code>DataKinds</code> gives enough of dependent typing to set up something called <a href=http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf><em>singleton types</em></a> which can in turn be used to tag the types of data sent over channel and ensure that types of responses matches that of the request.</p><h2 id=park-bench>Park Bench</h2><p>The perennial question of how to popularise Haskell in the industry sprung up again, with no new insights. After half an hour I finally registered that the first ten questions will be awarded with a copy of <em>Real World Haskell</em>, and while I don’t have much use for it at home, it could make a decent conversion device that could be put in some conspicuous place at work. My question was around the need for module system improvements such as <a href=http://plv.mpi-sws.org/backpack/><em>Backpack</em></a>. It was met mostly with blank stares from the panel, clearly none of the esteemed park benchers found this area of Haskell enough of a problem to pay close attention to the recent developments.</p><p>On a separate note, one interesting piece of opinion from Duncan Coutts was that type classes are overused and often a more suitable solution for where an OO-like construct is called for, is just a record with functions. And that’s all that stuck in my head from this small, but excellent Exchange.</p></main><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2022. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>