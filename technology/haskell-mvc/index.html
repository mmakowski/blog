<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Haskell MVC | Maciek's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/technology/>Tech</a></li><li><a href=/travel/>Travel</a></li><li><a href=/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Haskell MVC</span></h1></div><main><p><em><strong>with wxHaskell and STM</strong></em></p><p>With popularity of Haskell raising in recent years I have decided to have a look at how suitable it is as a general-purpose programming language. The experiment involves writing a <a href=https://github.com/mmakowski/habaz>Windows client for FIBS</a>.</p><p>It turned out to be far from easy.</p><p>It might be down to my lack of familiarity with functional programming patterns. Or perhaps, despite growing popularity, there are still no established FP GUI patterns yet. Either way, I struggled with structuring the code in a way that would let me work on the app incrementally, implementing a bit of game logic, a bit of GUI, connecting it together etc.</p><p>I therefore looked for help in the more familiar territory of object-oriented patterns and here’s what I came up with: a Model-View-Controller for Haskell.</p><p>The idea is to split the code roughly into modules corresponding to OO Model, View and Controller, with certain changes to accommodate different programming paradigm. Here’s how these modules will be playing together:</p><ul><li>Model defines a data type whose constructors represent states in which the model can be. It also provides functions which represent the transitions between states. Ideally it should be purely functional, with no side-effects.</li><li>View defines a data type whose value contains all elements of the view that need to be acted upon by Controller. It also defines (side-effecting) functions that represent atomic GUI updates, for use by the Controller. Finally it provides a <code>view</code> function that constructs the GUI. No application logic is encapsulated in this module.</li><li>Controller provides a <code>controller</code> function, that given a Model and a View ties them together and defines the application logic.</li></ul><p>This program is an attempt to demonstrate how this could work. I wanted to write it in literate style (.lhs) but it turned out that the support for Literate Haskell among HTML pretty-printers available to me is non-existent, so I decided for this semi-literate style instead.</p><p>To compile it run:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ghc -package wx MVC.hs
</span></span></code></pre></div><p>So, let’s have a look at the example.</p><h2 id=example>Example</h2><p>For the GUI we will use wxHaskell, hiding identifiers that will conflict with names we want to use for our own purposes:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>Graphics.UI.WX</span> <span style=color:#000;font-weight:700>hiding</span> (<span style=color:#458;font-weight:700>Menu</span>, <span style=color:#900;font-weight:700>menu</span>)
</span></span></code></pre></div><p>For running commands asynchronously we will need <code>forkIO</code> which runs an IO action in a new thread:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>Control.Concurrent</span> (<span style=color:#900;font-weight:700>forkIO</span>)
</span></span></code></pre></div><p>For communication between the UI and asynchronous processing threads we will use Software Transactional Memory (STM), in particular a transactional variable to hold current state of the Model:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>Control.Concurrent.STM.TVar</span> (<span style=color:#458;font-weight:700>TVar</span>, <span style=color:#900;font-weight:700>newTVarIO</span>, <span style=color:#900;font-weight:700>readTVar</span>, <span style=color:#900;font-weight:700>readTVarIO</span>,
</span></span><span style=display:flex><span>                                    <span style=color:#900;font-weight:700>writeTVar</span>)
</span></span></code></pre></div><p>Operations on <code>TVar</code> are modelled as STM monad. To have them actually performed we need <code>atomically</code> function which turns an STM action into an IO action:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>Control.Concurrent.STM</span> (<span style=color:#900;font-weight:700>atomically</span>)
</span></span></code></pre></div><p>In the main function of the app we need to:</p><ul><li>create the initial Model</li><li>create and start the View</li><li>run the controller function, passing to it the Model and the View</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>main</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>IO</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>main</span> <span style=color:#000;font-weight:700>=</span> start <span style=color:#000;font-weight:700>$</span> <span style=color:#000;font-weight:700>do</span>
</span></span><span style=display:flex><span>  v <span style=color:#000;font-weight:700>&lt;-</span> view
</span></span><span style=display:flex><span>  controller initialModel v
</span></span></code></pre></div><h3 id=model>Model</h3><p>Our Model will have two states: Locked and Unlocked, and a counter that counts the number of modifications:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Model</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Locked</span> <span style=color:#458;font-weight:700>Int</span>
</span></span><span style=display:flex><span>           <span style=color:#000;font-weight:700>|</span> <span style=color:#458;font-weight:700>Unlocked</span> <span style=color:#458;font-weight:700>Int</span>
</span></span><span style=display:flex><span>           <span style=color:#000;font-weight:700>deriving</span> <span style=color:#458;font-weight:700>Show</span>
</span></span></code></pre></div><p>We’ll have the model start in Locked state.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>initialModel</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Locked</span> <span style=color:#099>0</span>
</span></span></code></pre></div><p>Now we can define transitions between the states. Note that as long as the model is pure these will be pure functions. To make it obvious when we refer to Model state transitions let’s introduce a type alias:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#458;font-weight:700>ModelTransition</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Model</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>Model</span>
</span></span></code></pre></div><p>We’ll have <code>lock</code> and <code>unlock</code> transitions toggle between these two states:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>lock</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ModelTransition</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>lock</span> (<span style=color:#458;font-weight:700>Unlocked</span> n) <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Locked</span> n
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>unlock</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ModelTransition</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>unlock</span> (<span style=color:#458;font-weight:700>Locked</span> n) <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Unlocked</span> n
</span></span></code></pre></div><p>In addition, an Unlocked model can be modified. We intentionally make this transition slow to demonstrate how asynchronous processing is handled by the View and Controller:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>modify</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ModelTransition</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>modify</span> (<span style=color:#458;font-weight:700>Unlocked</span> n) <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Unlocked</span> (slowSucc n <span style=color:#099>100000000</span>)
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>where</span> slowSucc n <span style=color:#099>0</span> <span style=color:#000;font-weight:700>=</span> n <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>        slowSucc n k <span style=color:#000;font-weight:700>=</span> slowSucc n (k <span style=color:#000;font-weight:700>-</span> <span style=color:#099>1</span>)
</span></span></code></pre></div><h3 id=view>View</h3><p>We need a representation of View that exposes all its elements that Controller might need to access. Here the relevant elements include top-level window, the menu items and the model display. The menu items are nested to illustrate how hierarchical data structure can help in managing the view representation – in real application there will dozens of active UI elements and it would be awkward to have all of them listed as separate arguments to View datatype constructor.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>View</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>View</span> { mainWindow <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Frame</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span>                 , menu <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Menu</span>
</span></span></code></pre></div><p>We will use a static text control to display the state of the mode:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>                 , modelDisplay <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>StaticText</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>data</span> <span style=color:#458;font-weight:700>Menu</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Menu</span> { lockItem <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>MenuItem</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span>                 , unlockItem <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>MenuItem</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span>                 , modifyItem <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>MenuItem</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span>                 }
</span></span></code></pre></div><p>A counterpart to <code>ModelTransition</code> in the View is <code>ViewAction</code>, which given a Model and a View makes a change to the View:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#458;font-weight:700>ViewAction</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>Model</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>View</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>IO</span> <span style=color:#0086b3>()</span>
</span></span></code></pre></div><p>The atomic view actions we will need in this example are:</p><ul><li>disabling/enabling Lock/Unlock/Modify menu items</li><li>refreshing model display</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>enableLockItem</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>enableLockItem</span> <span style=color:#000;font-weight:700>_</span> v <span style=color:#000;font-weight:700>=</span> set (lockItem <span style=color:#000;font-weight:700>$</span> menu v) [ enabled <span style=color:#458;font-weight:700>:=</span> <span style=color:#458;font-weight:700>True</span> ]
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>disableLockItem</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>disableLockItem</span> <span style=color:#000;font-weight:700>_</span> v <span style=color:#000;font-weight:700>=</span> set (lockItem <span style=color:#000;font-weight:700>$</span> menu v) [ enabled <span style=color:#458;font-weight:700>:=</span> <span style=color:#458;font-weight:700>False</span> ]
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>enableUnlockItem</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>enableUnlockItem</span> <span style=color:#000;font-weight:700>_</span> v <span style=color:#000;font-weight:700>=</span> set (unlockItem <span style=color:#000;font-weight:700>$</span> menu v) [ enabled <span style=color:#458;font-weight:700>:=</span> <span style=color:#458;font-weight:700>True</span> ]
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>disableUnlockItem</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>disableUnlockItem</span> <span style=color:#000;font-weight:700>_</span> v <span style=color:#000;font-weight:700>=</span> set (unlockItem <span style=color:#000;font-weight:700>$</span> menu v) [ enabled <span style=color:#458;font-weight:700>:=</span> <span style=color:#458;font-weight:700>False</span> ]
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>enableModifyItem</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>enableModifyItem</span> <span style=color:#000;font-weight:700>_</span> v <span style=color:#000;font-weight:700>=</span> set (modifyItem <span style=color:#000;font-weight:700>$</span> menu v) [ enabled <span style=color:#458;font-weight:700>:=</span> <span style=color:#458;font-weight:700>True</span> ]
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>disableModifyItem</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>disableModifyItem</span> <span style=color:#000;font-weight:700>_</span> v <span style=color:#000;font-weight:700>=</span> set (modifyItem <span style=color:#000;font-weight:700>$</span> menu v) [ enabled <span style=color:#458;font-weight:700>:=</span> <span style=color:#458;font-weight:700>False</span> ]
</span></span></code></pre></div><p>View will not have a reference to the Model. Instead it will be told by the Controller when the View needs to be refreshed and the Model to be drawn will be provided then. Here, the function that will be invoked by the Controller is called <code>refreshModelDisplay</code> and just shows Model’s textual representation in the static text control:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>refreshModelDisplay</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>refreshModelDisplay</span> m v <span style=color:#000;font-weight:700>=</span> set (modelDisplay v) [ text <span style=color:#458;font-weight:700>:=</span> show m ]
</span></span></code></pre></div><p>Finally, we’ll need a device to combine these atomic actions into sequences that are themselves <code>ViewActions</code>. Let’s define a new operator <code>>&></code> to do just that:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>(<span style=color:#000;font-weight:700>&gt;&amp;&gt;</span>) <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>ViewAction</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>a1</span> <span style=color:#000;font-weight:700>&gt;&amp;&gt;</span> a2 <span style=color:#000;font-weight:700>=</span> <span style=color:#900;font-weight:700>\</span>m v <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>do</span> a1 m v; a2 m v
</span></span></code></pre></div><p>Note that we can pass the input <code>m</code> and <code>v</code> to subsequent actions because they have no effect on (pure) <code>m</code> and any side-effects will be reflected in GUI elements referenced from <code>v</code>.</p><p>The function that creates the view sets up all GUI elements but does not define any logic. It returns a <code>View</code> value in the context of an <code>IO</code> action.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>view</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>IO</span> <span style=color:#458;font-weight:700>View</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>view</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>do</span>
</span></span></code></pre></div><p>Our user interface will consist of a window with a menu containing items corresponding to each of Model transitions and a text display to show the state of the Model.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>  mainWindow <span style=color:#000;font-weight:700>&lt;-</span> frame [ text <span style=color:#458;font-weight:700>:=</span> <span style=color:#d14>&#34;MVC&#34;</span> ]
</span></span><span style=display:flex><span>  modelDisplay <span style=color:#000;font-weight:700>&lt;-</span> staticText mainWindow <span style=color:#458;font-weight:700>[]</span>
</span></span><span style=display:flex><span>  m <span style=color:#000;font-weight:700>&lt;-</span> menuPane [ text <span style=color:#458;font-weight:700>:=</span> <span style=color:#d14>&#34;Transition&#34;</span> ]
</span></span></code></pre></div><p>We have to ensure that the initial state of the View is consistent with the initial state of the Model. Model starts in Locked state, so “Lock” and “Modify” menu items have to be disabled:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>  lockItem <span style=color:#000;font-weight:700>&lt;-</span> menuItem m [ text <span style=color:#458;font-weight:700>:=</span> <span style=color:#d14>&#34;Lock&#34;</span>
</span></span><span style=display:flex><span>                         , enabled <span style=color:#458;font-weight:700>:=</span> <span style=color:#458;font-weight:700>False</span>
</span></span><span style=display:flex><span>                         ]
</span></span><span style=display:flex><span>  unlockItem <span style=color:#000;font-weight:700>&lt;-</span> menuItem m [ text <span style=color:#458;font-weight:700>:=</span> <span style=color:#d14>&#34;Unlock&#34;</span> ]
</span></span><span style=display:flex><span>  modifyItem <span style=color:#000;font-weight:700>&lt;-</span> menuItem m [ text <span style=color:#458;font-weight:700>:=</span> <span style=color:#d14>&#34;Modify&#34;</span>
</span></span><span style=display:flex><span>                           , enabled <span style=color:#458;font-weight:700>:=</span> <span style=color:#458;font-weight:700>False</span>
</span></span><span style=display:flex><span>                           ]
</span></span><span style=display:flex><span>  set mainWindow [ menuBar <span style=color:#458;font-weight:700>:=</span> [m] ]
</span></span></code></pre></div><p>Last but not least, to allow other threads to run we need a dummy timer running in the GUI. This is due to a wxHaskell glitch described, among other places, here: [http://stackoverflow.com/questions/3176682/wxhaskell-asynchronous-updates]</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>  t <span style=color:#000;font-weight:700>&lt;-</span> timer mainWindow [ interval <span style=color:#458;font-weight:700>:=</span> <span style=color:#099>10</span>, on command <span style=color:#458;font-weight:700>:=</span> return <span style=color:#0086b3>()</span> ]
</span></span><span style=display:flex><span>  return <span style=color:#000;font-weight:700>$</span> <span style=color:#458;font-weight:700>View</span> mainWindow
</span></span><span style=display:flex><span>                (<span style=color:#458;font-weight:700>Menu</span> lockItem unlockItem modifyItem)
</span></span><span style=display:flex><span>                modelDisplay
</span></span></code></pre></div><h3 id=controller>Controller</h3><p>So, we now have a Model with its transitions and a View with its actions. The job of Controller is to put these two together, i.e. perform Model and View updates according to user actions. The <code>controller</code> function is, on the face of it, very simple, it just creates a transactional variable to hold the Model, binds actions to UI elements and refreshes the View:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>controller</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>Model</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>View</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>IO</span> <span style=color:#0086b3>()</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>controller</span> model view <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>do</span>
</span></span></code></pre></div><p>The Model reference is stored in a transactional variable so that it can be modified by actions running concurrently in different threads.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>  modelTV <span style=color:#000;font-weight:700>&lt;-</span> newTVarIO model
</span></span><span style=display:flex><span>  bindGUIActions modelTV view
</span></span><span style=display:flex><span>  refreshModelDisplay model view
</span></span></code></pre></div><p>That’s it.</p><p>But what exactly happens in <code>bindGUIActions</code>? Before we get there, let’s ponder on this combining of Model transitions with View updates we just mentioned. How can this be achieved? What would be the type of this combination (let’s call it <code>ModelAndViewUpdate</code>)?</p><p>View updates are IO actions, so the result of the combination would have to yield an IO action. It would act upon a View and a Model. We chose to store the model in a <code>TVar</code>, so it would make sense for <code>ModelAndViewUpdate</code> to update this <code>TVar</code> as opposed to returning the modified Model in the context of IO. It seems we arrived at the following type for <code>ModelAndViewUpdate</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> <span style=color:#458;font-weight:700>ModelAndViewUpdate</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>TVar</span> <span style=color:#458;font-weight:700>Model</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>View</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>IO</span> <span style=color:#0086b3>()</span>
</span></span></code></pre></div><p>We can now manufacture these <code>ModelAndViewUpdates</code> from <code>ModelTransitions</code> and <code>ViewActions</code> as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>(<span style=color:#000;font-weight:700>&lt;@&gt;</span>) <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ModelTransition</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>ViewAction</span> <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#458;font-weight:700>ModelAndViewUpdate</span>
</span></span><span style=display:flex><span>(<span style=color:#000;font-weight:700>&lt;@&gt;</span>) modelTrans viewAct modelTV view <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>do</span>
</span></span></code></pre></div><ul><li>first we atomically apply the transition to the Model stored in <code>modelTV</code>:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>  atomically <span style=color:#000;font-weight:700>$</span> <span style=color:#000;font-weight:700>do</span>
</span></span><span style=display:flex><span>    model <span style=color:#000;font-weight:700>&lt;-</span> readTVar modelTV
</span></span><span style=display:flex><span>    writeTVar modelTV <span style=color:#000;font-weight:700>$</span> modelTrans model
</span></span></code></pre></div><ul><li>then invoke the View action passing to it the updated Model:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>  model <span style=color:#000;font-weight:700>&lt;-</span> readTVarIO modelTV
</span></span><span style=display:flex><span>  viewAct model view
</span></span></code></pre></div><p>Note we defined this function as an infix operator <code>&lt;@></code>, so applying it like in <code>modelTransition &lt;@> viewUpdate</code> will yield a <code>ModelAndViewUpdate</code> that is a combination of these two.</p><p>With this in place we can define <code>ModelAndViewUpdate</code>s for each UI action. First let’s combine atomic UI operations into complex ones corresponding to the Model transition. For <code>unlock</code> we will:</p><ul><li>enable Lock menu item</li><li>disable Unlock menu item</li><li>enable Modify menu item</li><li>refresh the model display</li><li>display an info dialog that the model has been unlocked.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>unlockVU</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>unlockVU</span> <span style=color:#000;font-weight:700>=</span> enableLockItem <span style=color:#000;font-weight:700>&gt;&amp;&gt;</span>
</span></span><span style=display:flex><span>           disableUnlockItem <span style=color:#000;font-weight:700>&gt;&amp;&gt;</span>
</span></span><span style=display:flex><span>           enableModifyItem <span style=color:#000;font-weight:700>&gt;&amp;&gt;</span>
</span></span><span style=display:flex><span>           refreshModelDisplay <span style=color:#000;font-weight:700>&gt;&amp;&gt;</span>
</span></span><span style=display:flex><span>           <span style=color:#900;font-weight:700>\</span><span style=color:#000;font-weight:700>_</span> v <span style=color:#000;font-weight:700>-&gt;</span> infoDialog (mainWindow v) <span style=color:#d14>&#34;Unlocked&#34;</span>
</span></span><span style=display:flex><span>                              <span style=color:#d14>&#34;Warning: the model can now be modified!&#34;</span>
</span></span></code></pre></div><p>and the <code>ModelAndViewUpdate</code> is now quite obvious:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>unlockCmd</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ModelAndViewUpdate</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>unlockCmd</span> <span style=color:#000;font-weight:700>=</span> unlock <span style=color:#000;font-weight:700>&lt;@&gt;</span> unlockVU
</span></span></code></pre></div><p>We can do the same for the remaining two actions (no dialog this time):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>lockVU</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ViewAction</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>lockVU</span> <span style=color:#000;font-weight:700>=</span> disableLockItem <span style=color:#000;font-weight:700>&gt;&amp;&gt;</span>
</span></span><span style=display:flex><span>         enableUnlockItem <span style=color:#000;font-weight:700>&gt;&amp;&gt;</span>
</span></span><span style=display:flex><span>         disableModifyItem <span style=color:#000;font-weight:700>&gt;&amp;&gt;</span>
</span></span><span style=display:flex><span>         refreshModelDisplay
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>lockCmd</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ModelAndViewUpdate</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>lockCmd</span> <span style=color:#000;font-weight:700>=</span> lock <span style=color:#000;font-weight:700>&lt;@&gt;</span> lockVU
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>modifyCmd</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ModelAndViewUpdate</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>modifyCmd</span> <span style=color:#000;font-weight:700>=</span> modify <span style=color:#000;font-weight:700>&lt;@&gt;</span> refreshModelDisplay
</span></span></code></pre></div><p>It’s prefreable to have <code>ModelAndViewUpdate</code>s defined in terms of <code>&lt;@></code>, since it guarantees that the Model updates behave well in muti-threaded scenario, but it’s not essential – nothing stops us from defining a value of type <code>ModelAndViewUpdate</code> by hand. If we do this extra care needs to be taken to ensure that Model updates don’t suffer from race conditions.</p><p>We are now ready to bind actions to UI elements.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#900;font-weight:700>bindGUIActions</span> <span style=color:#000;font-weight:700>::</span> <span style=color:#458;font-weight:700>ModelAndViewUpdate</span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>bindGUIActions</span> modelTV view <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>do</span>
</span></span><span style=display:flex><span>  set (lockItem <span style=color:#000;font-weight:700>$</span> menu view)   [ on command <span style=color:#458;font-weight:700>:=</span> run lockCmd ]
</span></span><span style=display:flex><span>  set (unlockItem <span style=color:#000;font-weight:700>$</span> menu view) [ on command <span style=color:#458;font-weight:700>:=</span> run unlockCmd ]
</span></span><span style=display:flex><span>  set (modifyItem <span style=color:#000;font-weight:700>$</span> menu view) [ on command <span style=color:#458;font-weight:700>:=</span> run modifyCmd ]
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>where</span>
</span></span></code></pre></div><p>What should <code>run</code> do? Its type signature needs to be <code>ModelAndViewUpdate -> IO ()</code>, i.e. <code>(TVar Model -> View -> IO ()) -> IO ()</code> which (not less than its name) suggests that it should execute supplied update function by passing <code>modelTV</code> and <code>view</code> to it. So we could simply do:</p><pre tabindex=0><code>run cmd = cmd modelTV view
</code></pre><p>and it would work as expected, with one caveat: if cmd was running for a long time it would freeze the UI, because the operation would be executed in the UI thread.</p><p>Well, we have imported <code>forkIO</code> for a reason:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>    run cmd <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>do</span>
</span></span><span style=display:flex><span>      forkIO <span style=color:#000;font-weight:700>$</span> cmd modelTV view
</span></span><span style=display:flex><span>      return <span style=color:#0086b3>()</span>
</span></span></code></pre></div><p>Now, note that as a result of this <code>forkIO</code> we are updating the UI from a non-UI thread. This is something most of UI toolkits prohibit. wxHaskell seems more permissive in this respect, but I have not investigated this matter fully. If it turns out that an update needs to be done in the UI thread then it significantly complicates the pattern. A possible solution would involve providing a transactional chanel (<code>TChan</code>) from the async thread to the GUI thread to which the async action would write required UI updates. These updates would then be read by a timer handler and applied to the View.</p><p>That concludes the example. Try running it and see how the UI actions behave. Try, for example, invoking “Modify” or “Lock” while other “Modify” is still running.</p><h2 id=discussion-and-disclaimers>Discussion and Disclaimers</h2><p>This, obviously, was a toy example. For real-life applications there is likely to be a couple of things which might need to be modified.</p><p>For instance, what if Model is not pure? The main thing that will break is <code>&lt;@></code> operator, since it executes a Model transition in STM monad, and that will not be possible if transition is tainted with IO. One solution will be to use a <code>TMVar</code> instead of <code>TVar</code> to store the Model. A value can be taken out of <code>TMVar</code> for the period of processing and then put back in, thus ensuring atomicity. This will increase synchronisation between threads but is unlikely to be a problem in practice.</p><p>What are the advantages of this pattern?</p><p>To me the most immediate benefit is that it imposes a structure on the code and defines boundaries which determine where ceratin piece of logic should be put. That’s the main thing I was trying to achieve in the context of my FIBS client app.</p><p>Another “structural” benefit is that it provides a decent separation of effectful, impure computations from pure functions. There is no escape from IO as far as GUI is concerned and the advantage of MVC is that it is restricted to View and upper layers of Controller.</p><p>Finally, as the example hopefully shows, the resulting structure is relatively easy to follow, even for FP newbies coming from OO background.</p><p>Any disadvantages?</p><p>It’s easy to see that View data type and the set of atomic ViewActions is going to be massive in a non-trivial app. Also all of these enable/disable ViewActions look like boilerplate.</p><p>The way <code>&lt;@></code> is defined, it is assumed that all UI updates take place after Model transition has completed. Sometimes it might be difficult to model the domain in such a way that Model and UI updates happen one after another and it might be desirable to update UI as the transition happens.</p><p>I’m sure I’ll discover more once I try to apply this pattern to my app.</p><p>And finally, some disclaimers:</p><p>As stated, I have not investigated fully the multi-threaded behaviour of wxHaskell. The FAQ at <a href=http://www.haskell.org/haskellwiki/WxHaskell/FAQ>http://www.haskell.org/haskellwiki/WxHaskell/FAQ</a> states that Haskell threads do not work with wxHaskell but does not specify what exactly is broken. My experiments seem to be contradicting that statement, but they might not have been complex enough to expose problems.</p><p>Furthermore, I’m new to Haskell and in spite of certain effort which I put into learning this stuff I still don’t fully grasp and lack intuition about some FP concepts so there might be aspects of this example which can be made more idiomatic or otherwise improved.</p><p>The raw source of this post can be found <a href=https://gist.github.com/850698>on Github</a>.</p></main><p class=date>10/03/2011</p><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2023. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>