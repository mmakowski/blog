<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Integration Testing with TeamCity | Maciek's blog</title><link rel=stylesheet href=/blog/css/style.css><link rel=stylesheet href=/blog/css/fonts.css></head><body><nav><ul class=menu><li><a href=/blog/technology/>Tech</a></li><li><a href=/blog/travel/>Travel</a></li><li><a href=/blog/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Integration Testing with TeamCity</span></h1><h2 class=date>2010/08/20</h2></div><main><p>Inspired by a recent seminar <a href=http://en.wikipedia.org/wiki/Ken_Schwaber>Ken Schwaber</a> presented at the company I work for, I decided to provide the means for ensuring that the high-level functionality of an application package built in our continuous integration environment (we use TeamCity) can be tested automatically.</p><h2 id=the-context>The Context</h2><p>Suppose we are working on a stand-alone java app (let’s call it <em>tc-rec</em>, after the app I have been setting up integration tests for) and have an existing build which generates a zip file containing all the jars and scripts required to run the app. The unit test coverage is decent, but by their nature unit tests do not prove that the built package can actually be executed -– a bug in the execution scripts or in the code performing dependency injection of the live app would not be detected by them. To test that the apps are actually runnable as built we are downloading the zip built by TeamCity, extracting it to some temporary directory and running through a series of sample input data sets and then inspecting the output to see if it matches what we expected.</p><p>Most of this is fairly easy to automate. The approach I chose was to have a script which grabs the built zip, extracts it to a temporary directory, runs a series of test cases, each containing input and expected output, and verifies that the output produced matches expected output. These integration test scripts are set up as a separate project –- in this way it is not tied to a particular build of a tested app and we can just drop a zip file into the test directory and have it tested. The directory structure is as follows:</p><pre tabindex=0><code>/tc-rec
  /src
  /target         &lt;-- the build puts tc-rec-x.y.z.zip in this directory
/tc-rec-integration-tests
  /tests
    /test-suite-1
      /test-case-1
        /input
        /output
      ... (more test suites and cases)
  /target         &lt;-- this directory is created by test scripts
    /test-suite-1
      /test-case-1
      ...
  /work           &lt;-- created by test scripts and deleted at the end
    /app          &lt;-- the app is unzipped to this directory
    /test-suite-1 &lt;-- each test case has its own work area
      /test-case-1
      ...
</code></pre><p>I decided to script it up in Python because of prior familiarity and it already having been used in our environment, but anything that can be run from TeamCity (or just a command line, for that matter) would do.</p><h2 id=teamcity-setup>TeamCity Setup</h2><p>In TeamCity, <em>tc-rec</em> was set up as a separate build configuration, generating a single artifact: <code>tc-rec-x.y.z.zip</code>. I set up a new TeamCity build configuration, <em>tc-rec-integration-tests</em> and made it dependent on the zip file generated by <em>tc-rec</em> in such a way, that the latest zip would be copied to <em>tc-rec-integration-tests</em> root directory when that build kicks off. <em>tc-rec-integration-tests</em> build was also made to run whenever <em>tc-rec</em> build completed, thus testing that every zip produced by TeamCity passes the integration tests.</p><h2 id=reporting-test-results>Reporting Test Results</h2><p>Now, after a couple of failed builds and sorting out the build agent’s settings and paths, the build should be up and running in TeamCity. The point of the exercise, though, is to have an easy way of checking the health of latest build. How do we tell TeamCity to fail the <em>tc-rec-integration-tests</em> build if any of the tests fail?</p><p>Assuming we are using command line runner (as I do for running the Python scripts), TeamCity will check the exit code of the command executed and set the build status accordingly. The first step is then to make sure that any failure during the execution of the test scripts sets the exit code to non-zero. That will provide the basic passed/failed indication for the entire integration tests build.</p><p>Even more helpful would be the ability to tell which exact test failed and what the reason was. Printing out diagnostics to stdout/stderr can help – all these messages will end up in the build log displayed in one of TeamCity’s tabs, and which can be looked at to determine the reason for failure. There is a more practical solution though: command line runner can be set up to watch for test result files in common formats (Ant’s JUnit, Maven’s Surefire) and nothing prevents us from writing these from the test scripts. I decided on Surefire XML, which can be generated using these templates:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>REPORT_TEMPLATE <span style=color:#000;font-weight:700>=</span> <span style=color:#d14>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;testsuite name=&#34;</span><span style=color:#d14>%s</span><span style=color:#d14>&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>           errors=&#34;0&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>           skipped=&#34;0&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>           tests=&#34;</span><span style=color:#d14>%s</span><span style=color:#d14>&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>           failures=&#34;</span><span style=color:#d14>%s</span><span style=color:#d14>&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>           time=&#34;</span><span style=color:#d14>%s</span><span style=color:#d14>&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#d14></span><span style=color:#d14>%s</span><span style=color:#d14>
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;/testsuite&gt;&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SUCCESSFUL_TEST_CASE_TEMPLATE <span style=color:#000;font-weight:700>=</span> <span style=color:#d14>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#d14>  &lt;testcase name=&#34;</span><span style=color:#d14>%s</span><span style=color:#d14>&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>            time=&#34;</span><span style=color:#d14>%s</span><span style=color:#d14>&#34;/&gt;
</span></span></span><span style=display:flex><span><span style=color:#d14>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FAILED_TEST_CASE_TEMPLATE <span style=color:#000;font-weight:700>=</span> <span style=color:#d14>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#d14>  &lt;testcase name=&#34;</span><span style=color:#d14>%s</span><span style=color:#d14>&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>            time=&#34;</span><span style=color:#d14>%s</span><span style=color:#d14>&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#d14>    &lt;failure type=&#34;failure&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#d14>        </span><span style=color:#d14>%s</span><span style=color:#d14>
</span></span></span><span style=display:flex><span><span style=color:#d14>    &lt;/failure&gt;
</span></span></span><span style=display:flex><span><span style=color:#d14>  &lt;/testcase&gt;
</span></span></span><span style=display:flex><span><span style=color:#d14>&#39;&#39;&#39;</span>
</span></span></code></pre></div><p>With test report files in place TeamCity will display a nice summary and track performance of the tests over subsequent builds – as it does with standard JUnit tests.</p><h2 id=viewing-the-output>Viewing the Output</h2><p>One final useful thing would be to be able to visually inspect the output generated by the application during test runs. TeamCity makes it easy through its artifact publishing mechanism. After adding the path to the <code>target</code> directory to artifact paths we can browse the output directly from TeamCity’s web page.</p><p>Now we are all set for quick feedback on the build health. All that remains is writing some meaningful integration test cases.</p></main><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2022. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>