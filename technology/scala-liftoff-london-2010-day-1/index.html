<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Scala LiftOff London 2010 - Day 1 | Maciek's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css></head><body><nav><ul class=menu><li><a href=/technology/>Tech</a></li><li><a href=/travel/>Travel</a></li><li><a href=/cooking/>Cook</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Scala LiftOff London 2010 - Day 1</span></h1></div><main><p>The first day of this year’s Scala Lift Off London exceeded my modest expectations. It was full of excellent presentations and interesting discussions attended by very friendly folk. I trust tomorrow will not be worse; in the mean time here are some notes from the sessions I attended.</p><h2 id=session-1-from-java-to-scala>Session 1: From Java to Scala</h2><p><a href=http://blog.tackley.net>Graham Tackley</a> of guardian.co.uk told us about the experience of his team with embracing Scala. Guardian.co.uk had been a Java shop and when a project to provide API to access all of their content had been started their technology stack of choice was Java, Guice and Apache Solr. Then, at some point, Graham started playing with Scala and decided to use it for testing. The experience was positive enough for him and his team to decide to rewrite the project in Scala, which has been aided by a Java-to-Scala conversion feature of IntelliJ IDEA. The team then progressed from, as Graham put it, “Java without semicolons”, to more advanced features of Scala, embracing functional concepts like <code>map</code> and <code>flatMap</code>. Overall the experience was a very positive one, with the use of a new programming language putting back excitement into what used to be a fairly mundane Java/Spring/Hibernate-based routine and with no major complaints about the tooling available. The message, confirmed by voices from the audience, was that it is easiest to start using Scala for the test code, and after a while the developers will be so put off by the unnecessary verbosity, noisiness and lack of expresiveness of Java that they will push for Scala all way through. It might be a bit more difficult to sell the language to the managers and customers though.</p><p>The slides from Graham’s talk are available <a href=http://www.slideshare.net/tackers/java-to-scala>here</a>.</p><p><a href=http://www.slideshare.net/tackers/java-to-scala>http://www.slideshare.net/tackers/java-to-scala</a></p><h2 id=session-2-akka>Session 2: Akka</h2><p>Presented by <a href=http://jonasboner.com>Jonas Bonér</a>, the creator of <a href=http://akkasource.org>Akka</a>, this session was an overview of the framework. Working as a consultant and faced with the challenges of high-concurrency, scalability and fault-tolerance Jonas wanted to employ the tried and tested mechanisms of Erlang. This, more often than not, did not go down well with the clients who treated Erlang as an exotic platform and would prefer something they are familiar with, e.g. the JVM. This prompted him to create a framework which could provide these mechanisms on the platform customers wanted. As a result Akka implements actors, multiple dispatch mechanisms to choose from, supervisors (actors that can react to failures of other actors) which can be organised into hierarchies, and strategies for restarting failed actors or groups thereof. All that is supported by interfaces in both Java and Scala. Furthermore, Akka actors and supervisors can be configured as Spring beans and the framework can make use of integration features provided by <a href=http://camel.apache.org>Apache Camel</a>.</p><p>Martin Odersky (the creator and main designer of Scala) turned up at this talk and a discussion ensued on Scala actors vs. Akka actors and their relatvie merits. The consensus seems to be that either have been designed with slightly different goals and that Scala actors are more feature-rich and closer to their Erlang counterparts at the expense of performance. The primary source of the performance difference is the fact that unhandled messages are left in Scala actor’s mailbox and make the search for further messages take longer, while Akka throws an exception whenever a message is not matched by any of the <code>receive</code> patterns. Another interesting comparison discussed was between Akka (or, more general, JVM) and Erlang. In Erlang each process (i.e. actor) has its own heap and messages have to be physically copied between process memories. In contrast all actors running in a single JVM share the same heap which provides an opportunity for better performance, but also for all the pitfalls of shared-state concurrency in case a reference to a mutable object is passed in a message. Finally, Jonas has shown how big an impact synchronicity has on the performance: using <code>!!</code> (synchronous <em>send</em> which waits on a <code>Future</code> to receive a response) as opposed to <code>!</code> (asynchronous <em>send</em> which returns immediately) reduced the throughput of the tested system by up to 80%.</p><p>An interesting piece of Scala trivia (from Martin Odersky): <code>asInstanceOf</code> was intentionally chosen to be long and unwieldy to discourage explicit casts.</p><h2 id=session-3-writing-compiler-plug-ins>Session 3: Writing Compiler Plug-ins</h2><p>I have been some ten minutes late to this session due to an unfortunate chain of events, which involved the Akka session taking half an hour more than the allocated time and me desiring to eat a proper lunch at a nearby Italian café. I have therefore missed out on Iulian Dragos explaining the basics of <a href=http://github.com/dragos/noboxing-plugin>noboxing plug-in</a>. Nevertheless, it could be inferred from the words of Iulian and Kevin Wright, who co-hosted this session, that Scala compiler’s plug-in infrastructure allows to easily instert a new compilation phase, but not modify what happens during the existing phases (parsing, typing, erasure, code generation). This leads to problems when trying to implement a <code>Transformer</code> that would add new definitions to the code: if it is run before the typer phase it won’t have access to all type information that might be required to generate the methods; if it is run after typer then any code that relies on the presence of definitions generated by the plug-in will report error during type-checking. The work-around used by Kevin in his <a href=http://github.com/scala-incubator/autoproxy-plugin>autoproxy plug-in</a> is to run a custom type-checking phase inside the plug-in, but it has been agreed that there is currently no easy way to make plug-in insert new methods based on the type information. Plug-ins that modify code withing existing methods or just analyse the AST are, on the other hand, relatively simple to write.</p><h2 id=session-4-scala-28-collections>Session 4: Scala 2.8 Collections</h2><p>The final session of the day was somewhat whimsically named “Scala Wizardry” and was meant to discuss more exotic features of the language like implicits, higher-kinded types, cake pattern and explicit self-typing. However, it has been swiftly taken over by Mr. Odersky who covered the re-design of collections in Scala 2.8 while touching upon most of these advanced subjects. He described how the requirement for methods like <code>filter</code> to return the type of collection it was invoked on led to a lot of code duplication and unsightly type casts in Scala 2.7. The initial attempt to tackle it in 2.8 involved higher-kinded types:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>trait</span> <span style=color:#458;font-weight:700>TraversableLike</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span>, <span style=color:#458;font-weight:700>CC</span><span style=color:#000;font-weight:700>[</span><span style=color:#000;font-weight:700>_</span><span style=color:#000;font-weight:700>]]</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>def</span> filter<span style=color:#000;font-weight:700>(</span>p<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>A</span> <span style=color:#000;font-weight:700>=&gt;</span> <span style=color:#458;font-weight:700>Boolean</span><span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>CC</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>def</span> map<span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>](</span>f<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>A</span> <span style=color:#000;font-weight:700>=&gt;</span> B<span style=color:#000;font-weight:700>)</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>CC</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>trait</span> <span style=color:#458;font-weight:700>Traversable</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span><span style=color:#000;font-weight:700>]</span> <span style=color:#458;font-weight:700>extends</span> <span style=color:#458;font-weight:700>TraversableLike</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span>, <span style=color:#458;font-weight:700>Traversable</span><span style=color:#000;font-weight:700>]</span>
</span></span></code></pre></div><p><code>TraversableLike</code> is a higher-kinded type because its second parameter is not a type but a <em>type constructor</em>. When <code>Traversable[A]</code> is defined, <code>Traversable</code> (without type parameters) denotes said type constructor.</p><p>This initial design dealt with 90%+ of cases, but there were still some issues remaining; one of them was that <code>map</code> needs to change the type of the collection when the return type of supplied function requires it. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>val</span> bits <span style=color:#000;font-weight:700>=</span> <span style=color:#458;font-weight:700>BitSet</span><span style=color:#000;font-weight:700>(</span><span style=color:#099>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#099>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#099>4</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>bits map <span style=color:#000;font-weight:700>(</span><span style=color:#000;font-weight:700>_</span><span style=color:#000;font-weight:700>.</span>toString<span style=color:#000;font-weight:700>)</span>  <span style=color:#998;font-style:italic>// should return Set[String]
</span></span></span></code></pre></div><p>This required some sort of rule engine to work out the appropriate type in each case. One can imagine a predicate <code>CanBuildFrom[From, Elem, To]</code> where <code>From</code> and <code>To</code> are collection types and <code>Elem</code> is the return type of the function passed to <code>map</code>. The rules could then be expressed as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#458;font-weight:700>CanBuildFrom</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>BitSet</span>, <span style=color:#458;font-weight:700>Int</span>, <span style=color:#458;font-weight:700>BitSet</span><span style=color:#000;font-weight:700>]</span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>CanBuildFrom</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>BitSet</span>, <span style=color:#458;font-weight:700>B</span>, <span style=color:#458;font-weight:700>Set</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>]]</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>...</span>
</span></span></code></pre></div><p>We would also like to be able to express constraints like this (in Prolog-like notation):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#458;font-weight:700>CanBuildFrom</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>SortedSet</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span><span style=color:#000;font-weight:700>]</span>, <span style=color:#458;font-weight:700>B</span>, <span style=color:#458;font-weight:700>SortedSet</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>]]</span> <span style=color:#000;font-weight:700>:</span><span style=color:#458;font-weight:700>-</span> <span style=color:#458;font-weight:700>Ordering</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>]</span>
</span></span></code></pre></div><p>It turns out these rules can be encoded in Scala using implicits. I’ve taken the below snippet from my notes and it might lack necessary details (or be partially incorrect, for that matter), but it should give an idea of the sort of machinery that is involved – and sophistication of the language that allows this to work:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#000;font-weight:700>implicit</span> <span style=color:#000;font-weight:700>def</span> bf1<span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span>, <span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>]</span><span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>CanBuildFrom</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>Set</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span><span style=color:#000;font-weight:700>]</span>, <span style=color:#458;font-weight:700>B</span>, <span style=color:#458;font-weight:700>Set</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>]]</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>implicit</span> <span style=color:#000;font-weight:700>def</span> bf2<span style=color:#000;font-weight:700>:</span> <span style=color:#458;font-weight:700>CanBuildFrom</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>Set</span><span style=color:#000;font-weight:700>[</span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>implicit</span> <span style=color:#458;font-weight:700>def</span> <span style=color:#458;font-weight:700>bf3</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span><span style=color:#000;font-weight:700>]</span><span style=color:#458;font-weight:700>:</span> <span style=color:#458;font-weight:700>CanBuildFrom</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>BitSet</span>, <span style=color:#458;font-weight:700>A</span>, <span style=color:#458;font-weight:700>Set</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span><span style=color:#000;font-weight:700>]]</span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>//</span> <span style=color:#458;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>implicit</span> <span style=color:#458;font-weight:700>def</span> <span style=color:#458;font-weight:700>bfn</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span>, <span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>](</span><span style=color:#458;font-weight:700>implicit</span> <span style=color:#458;font-weight:700>ord:</span> <span style=color:#458;font-weight:700>Ordering</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>])</span><span style=color:#458;font-weight:700>:</span>
</span></span><span style=display:flex><span>            <span style=color:#458;font-weight:700>CanBuildFrom</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>SortedSet</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span><span style=color:#000;font-weight:700>]</span>, <span style=color:#458;font-weight:700>B</span>, <span style=color:#458;font-weight:700>SortedSet</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>]]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>trait</span> <span style=color:#458;font-weight:700>TraversableLike</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>A</span>, <span style=color:#458;font-weight:700>Coll</span><span style=color:#000;font-weight:700>]</span> <span style=color:#000;font-weight:700>{</span> <span style=color:#458;font-weight:700>this:</span> <span style=color:#458;font-weight:700>Coll</span> <span style=color:#000;font-weight:700>=&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>def</span> <span style=color:#458;font-weight:700>map</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>B</span>, <span style=color:#458;font-weight:700>To</span><span style=color:#000;font-weight:700>](</span><span style=color:#458;font-weight:700>f:</span> <span style=color:#458;font-weight:700>A</span> <span style=color:#000;font-weight:700>=&gt;</span> <span style=color:#458;font-weight:700>B</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>                <span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>implicit</span> <span style=color:#458;font-weight:700>cbf:</span> <span style=color:#458;font-weight:700>CanBuildFrom</span><span style=color:#000;font-weight:700>[</span><span style=color:#458;font-weight:700>Coll</span>, <span style=color:#458;font-weight:700>B</span>, <span style=color:#458;font-weight:700>To</span><span style=color:#000;font-weight:700>])</span><span style=color:#458;font-weight:700>:</span> <span style=color:#458;font-weight:700>To</span> <span style=color:#458;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>val</span> <span style=color:#458;font-weight:700>b</span> <span style=color:#458;font-weight:700>=</span> <span style=color:#458;font-weight:700>cbf</span><span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>this</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>foreach</span> <span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>x</span> <span style=color:#000;font-weight:700>=&gt;</span> <span style=color:#458;font-weight:700>b</span> <span style=color:#458;font-weight:700>+=</span> <span style=color:#458;font-weight:700>f</span><span style=color:#000;font-weight:700>(</span><span style=color:#458;font-weight:700>x</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span>    <span style=color:#458;font-weight:700>b.result</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#458;font-weight:700>//</span> <span style=color:#458;font-weight:700>...</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Martin did admit that these weird method signatures can scare people off and while they are relevant for library developers the users of the library should not be bothered with them. The rule of thumb is: if what you desire can be expressed in simple types then use simple types. Which seems as a special case of the universal KISS rule. Definitely advisable when dealing with implicits and higher-kinded types.</p><p>The collections re-design is described in a <a href=http://lampwww.epfl.ch/~odersky/papers/fsttcs2009.pdf>paper</a> written by Odersky and Adriaan Moors.</p><p><a href=https://blog.mmakowski.com/technology/scala-liftoff-london-2010-day-2/>Day Two →</a></p></main><p class=date>10/10/2010</p><footer><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><hr>© Maciek Makowski 2010 &ndash; 2023. Content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a></footer></body></html>